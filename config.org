:PROPERTIES:
:ID:       21f80d7d-00f7-4959-9ea2-d7e4b680b272
:END:
#+title: My Doom Emacs configuration
#+PROPERTY: header-args:emacs-lisp :tangle config.el
#+startup: hideblocks content
#+filetags: :compilation:tool:blogs:
#+date: {{{modification-time(%Y-%m-%d)}}}
#+export_file_name: Doom-Emacs-config.md
#+options: toc:5 num:t H:5

* Prerequisites
** Reproducible information
This configuration is continuingly being improved.
I build my own Emacs from source in order to take advantage of some experimental features.
There are also =(packages! ...)=  calls to external Emacs packages that are not pinned to any specific version.
As such, there might be incompabilities if one blindly copies codes from this configurations.
Although I'll try to document which features are based on developing softwares and are likely to be changed in the future, it is inevitable that some bits of information are going to fall through the cracks.

In this section, I reiterate the relevant info about the version of the software I'm using here, in case someone finds this infomation useful.
Here's my current build of Emacs:

#+begin_src emacs-lisp :exports output :tangle no :eval t
(emacs-version)
#+end_src

#+RESULTS:
: GNU Emacs 29.1 (build 1, x86_64-pc-linux-gnu, GTK+ Version 3.24.38, cairo version 1.17.8)
:  of 2023-07-30

This Emacs is built with the following configuration options:

#+begin_src emacs-lisp :exports output :tangle no :eval t
system-configuration-options
#+end_src

#+RESULTS:
: --with-modules --with-json --with-mailutils --with-rsvg --with-native-compilation --with-xinput2 --with-gif --with-pgtk --with-tree-sitter

#+begin_src emacs-lisp :exports output :tangle no :eval t
system-configuration-features
#+end_src

#+RESULTS:
: ACL CAIRO DBUS FREETYPE GIF GLIB GMP GNUTLS GPM GSETTINGS HARFBUZZ JPEG JSON LCMS2 LIBSYSTEMD LIBXML2 MODULES NATIVE_COMP NOTIFY INOTIFY PDUMPER PGTK PNG RSVG SECCOMP SOUND SQLITE3 THREADS TIFF TOOLKIT_SCROLL_BARS TREE_SITTER WEBP XIM GTK3 ZLIB

* Fundamental setups
** Some good defaults

#+begin_src emacs-lisp
;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
(setq user-full-name "Sam Lazrak"
      user-mail-address "24284329+samlazrak@users.noreply.github.com"
      +doom-dashboard-banner-dir doom-user-dir
      +doom-dashboard-banner-file "emacse.svg"
      +doom-dashboard-banner-size 400
      +doom-dashboard-banner-padding '(0 . 2))

;; Suppress deprecated cl package warnings
(setq byte-compile-warnings '(not cl-functions obsolete))

;; Turn on abbrev mode
(setq-default abbrev-mode t)

;; Start Doom fullscreen
(add-to-list 'default-frame-alist '(width . 92))
(add-to-list 'default-frame-alist '(height . 40))
;; (add-to-list 'default-frame-alist '(alpha 97 100))

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(if (and (string-match-p "Windows" (getenv "PATH")) (not IS-WINDOWS))
    (setq dropbox-directory "/mnt/c/Users/m3/Dropbox/")
  (setq dropbox-directory "~/Dropbox/"))

(setq org-directory "~/org")

;; Add org-roam tools to PATH
(setenv "PATH" (concat (expand-file-name "~/org/roam/tools/bin") ":" (getenv "PATH")))
(add-to-list 'exec-path (expand-file-name "~/org/roam/tools/bin"))

;; Use POSIX shell for internal Emacs processes to avoid issues with non-POSIX shells
;;(setq shell-file-name (executable-find "bash"))

;; But use Fish for terminal emulators
(setq-default vterm-shell "/opt/homebrew/bin/fish")
(setq-default explicit-shell-file-name "/opt/homebrew/bin/fish")

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type 'relative)
(remove-hook! '(text-mode-hook) #'display-line-numbers-mode)

(setq frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name))))))
#+end_src

** Theme
I have done a fair share of theme-hopping. In the end, I always come back to a variant of the [[https://github.com/morhetz/gruvbox][Gruvbox color scheme]].
If you are viewing this on my website, you may find that this color scheme is ubiquitous here.

#+begin_src emacs-lisp
;; The custom doom-everforest theme is a green-accented variant of gruvbox-material
(setq doom-theme 'doom-gruvbox)

(use-package! doom-modeline
  :config
  (setq doom-modeline-persp-name t))
#+end_src

** Font configs
*** Font choices
[[https://typeof.net/Iosevka/][Iosevka]] is a great font with good coverage (excellent if you count its extension Sarasa Gothic).
The narrow glyphs allow us to save some precious screen real estate.
This is particularly useful for multitasking with multiple windows open.
For example, my notetaking workflow involved having a small (not maximized) Emacs window, along with one or several windows for pdf viewers, often on a 13-inch laptop screen.
You can see the benefit here.
I cannot go back to non-narrow fonts anymore.

It's even better that it allows me to cherry-pick glyphs that I like (or don't like).
My customized Iosevka is based on the Ubuntu Mono style variant (SS12).
This style brings me that nostalgic feel of my first linux distribution.
The underscore =_= is more pronounced, which I like.
The stylized letters (e.g. see =l=, =m=, =n=, =i=, =j=,...) bring forth a humanist, comfy yet quirky aesthetic.

Below is my =private-build-plans.toml=, made with this [[https://typeof.net/Iosevka/customizer][lovely customizer]].
The font compilation takes quite a while, though.
Make sure to consult with the [[https://github.com/be5invis/Iosevka/blob/main/doc/custom-build.md][instructions]]:

#+begin_src toml :tangle no
[buildPlans.iosevka-custom]
family = "Iosevka Custom"
spacing = "normal"
serifs = "sans"
noCvSs = true
export-glyph-names = false

  [buildPlans.iosevka-custom.variants]
  inherits = "ss12"

    [buildPlans.iosevka-custom.variants.design]
    v = "straight-serifed"
    lower-alpha = "crossing"
    capital-gamma = "top-right-serifed"
    zero = "dotted"
    ampersand = "et-toothed"
    lig-ltgteq = "slanted"

  [buildPlans.iosevka-custom.ligations]
  inherits = "julia"
#+end_src

*** Setups
Now to set all this up:

#+begin_src emacs-lisp
(when (doom-font-exists-p "FiraMono Nerd Font Mono")
    (setq doom-font                (font-spec :name "FiraMono Nerd Font Mono" :size 16)))
(when (doom-font-exists-p "FiraCode Nerd Font Propo")
    (setq doom-variable-pitch-font (font-spec :name "FiraCode Nerd Font Propo"  :size 18)))
(when (doom-font-exists-p "Noto Color Emoji")
    (setq doom-emoji-font          (font-spec :name "Noto Color Emoji")))
(when (doom-font-exists-p "FiraMono Nerd Font Mono")
    (setq doom-symbol-font         (font-spec :name "FiraMono Nerd Font Mono")))
#+end_src

Fallback font for non-ascii glyphs:

#+begin_src emacs-lisp
(use-package! unicode-fonts
  :config
  ;; Common math symbols
  (dolist (unicode-block '("Mathematical Alphanumeric Symbols"))
    (push "JuliaMono Nerd Font Mono" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  (dolist (unicode-block '("Greek and Coptic"))
    (push "FiraMono Nerd Font Mono" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  ;; CJK characters
  (dolist (unicode-block '("CJK Unified Ideographs" "CJK Symbols and Punctuation" "CJK Radicals Supplement" "CJK Compatibility Ideographs"))
    (push "Sarasa Mono SC" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  (dolist (unicode-block '("Hangul Syllables" "Hangul Jamo Extended-A" "Hangul Jamo Extended-B"))
    (push "Sarasa Mono K" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  ;; Emojis
  (dolist (unicode-block '("Miscellaneous Symbols"))
    (push "Noto Color Emoji" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  ;; Other unicode block
  (dolist (unicode-block '("Braille Patterns"))
    (push "FiraMono Nerd Font Mono" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  )
#+end_src

*** Ligatures
Emacs (since version 28 I think) handles ligatures pretty well.
However, sometimes we still need to manually fix some ligature composition:

#+begin_src emacs-lisp :tangle no
;; For Iosevka
;; (set-char-table-range composition-function-table ?+ '(["\\(?:+[\\*]\\)" 0 font-shape-gstring]))
(set-char-table-range composition-function-table ?* '(["\\(?:\\*?[=+>]\\)" 0 font-shape-gstring]))
;; (set-char-table-range composition-function-table ?= '(["\\(?:=?[=\\*]\\)" 0 font-shape-gstring]))
;; (set-char-table-range composition-function-table ?= '(["\\(?:=?[\\*:]\\)" 0 font-shape-gstring]))
;; (set-char-table-range composition-function-table ?: '(["\\(?::=\\)" 0 font-shape-gstring]))
;; For Alegreya/Alegreya Sans
(set-char-table-range composition-function-table ?f '(["\\(?:ff?[fijltkbh]\\)" 0 font-shape-gstring]))
;; (set-char-table-range composition-function-table ?T '(["\\(?:Th\\)" 0 font-shape-gstring]))
#+end_src

*** Mixed- and fixed-pitch fonts
We should take care of =mixed-pitch-mode= here, too:

#+begin_src emacs-lisp
(use-package! mixed-pitch
  :hook ((org-mode      . mixed-pitch-mode)
         (org-roam-mode . mixed-pitch-mode))
  :config
  (pushnew! mixed-pitch-fixed-pitch-faces
            'warning
            'org-drawer 'org-cite-key 'org-list-dt 'org-hide
            'corfu-default)
  (setq mixed-pitch-set-height t))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
** Modeline
Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

Recent version of [[https://github.com/seagle0128/doom-modeline/pull/622][doom-modeline]] features [[github:rainstormstudio/nerd-icons.el][nerd-icons.el]] instead of [[github:domtronn/all-the-icons.el][all-the-icons.el]].
I like this change, however different parts of Doom are still using =all-the-icons= under the hood.
Some custom configurations is needed for now.

#+begin_src emacs-lisp
(use-package! nerd-icons
  :custom
  (nerd-icons-font-family "FiraMono Nerd Font Mono")
  (nerd-icons-scale-factor 1.2)
  (nerd-icons-default-adjust 0)
  (doom-modeline-major-mode-icon t))
#+end_src

** Narrowing and center buffer contents
On larger screens I like buffer contents to not exceed a certain width and are centered.
=olivetti-mode= solves this problem nicely.
There is also an =auto-olivetti-mode=  which automatically turns on =olivetti-mode= in most buffers.

#+begin_src emacs-lisp
(use-package! olivetti
  :config
  (setq-default olivetti-body-width 130)
  (add-hook 'mixed-pitch-mode-hook  
            (lambda () 
              (when (and (bound-and-true-p olivetti-mode)
                         (or (not (numberp olivetti-body-width))
                             (eq olivetti-body-width 'unspecified)))
                (setq-local olivetti-body-width 90)))))

(use-package! auto-olivetti
  :custom
  (auto-olivetti-enabled-modes '(text-mode prog-mode helpful-mode ibuffer-mode image-mode))
  :config
  ;; Fix for olivetti-body-width being set to 'unspecified
  (defadvice! +olivetti-fix-unspecified-width-a (&rest _)
    "Fix olivetti-body-width when it gets set to 'unspecified."
    :before #'olivetti-set-window
    (when (or (not (numberp olivetti-body-width))
              (eq olivetti-body-width 'unspecified))
      (setq-local olivetti-body-width 130)))
  
  ;; Remove the error handling approach and try a different strategy
  ;; This wrapper suppresses the error messages while preserving functionality
  (defun olivetti--suppress-errors (orig-fn &rest args)
    "Suppress olivetti error messages."
    (let ((inhibit-message t)
          (message-log-max nil))
      (condition-case nil
          (apply orig-fn args)
        (error nil))))
  
  ;; Apply error suppression to the functions that generate errors
  (advice-add 'olivetti-set-window :around #'olivetti--suppress-errors)
  (advice-add 'olivetti-normalize-width :around #'olivetti--suppress-errors)
  
  (auto-olivetti-mode))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
** Modeline
Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

Recent version of [[https://github.com/seagle0128/doom-modeline/pull/622][doom-modeline]] features [[github:rainstormstudio/nerd-icons.el][nerd-icons.el]] instead of [[github:domtronn/all-the-icons.el][all-the-icons.el]].
I like this change, however different parts of Doom are still using =all-the-icons= under the hood.
Some custom configurations is needed for now.

#+begin_src emacs-lisp
(use-package! nerd-icons
  :custom
  (nerd-icons-font-family "FiraMono Nerd Font Mono")
  (nerd-icons-scale-factor 1.2)
  (nerd-icons-default-adjust 0)
  (doom-modeline-major-mode-icon t))
#+end_src

** Narrowing and center buffer contents
On larger screens I like buffer contents to not exceed a certain width and are centered.
=olivetti-mode= solves this problem nicely.
There is also an =auto-olivetti-mode=  which automatically turns on =olivetti-mode= in most buffers.

#+begin_src emacs-lisp
(use-package! olivetti
  :config
  (setq-default olivetti-body-width 130)
  (add-hook 'mixed-pitch-mode-hook  
            (lambda () 
              (when (and (bound-and-true-p olivetti-mode)
                         (or (not (numberp olivetti-body-width))
                             (eq olivetti-body-width 'unspecified)))
                (setq-local olivetti-body-width 90)))))

(use-package! auto-olivetti
  :custom
  (auto-olivetti-enabled-modes '(text-mode prog-mode helpful-mode ibuffer-mode image-mode))
  :config
  ;; Fix for olivetti-body-width being set to 'unspecified
  (defadvice! +olivetti-fix-unspecified-width-a (&rest _)
    "Fix olivetti-body-width when it gets set to 'unspecified."
    :before #'olivetti-set-window
    (when (or (not (numberp olivetti-body-width))
              (eq olivetti-body-width 'unspecified))
      (setq-local olivetti-body-width 130)))
  
  ;; Remove the error handling approach and try a different strategy
  ;; This wrapper suppresses the error messages while preserving functionality
  (defun olivetti--suppress-errors (orig-fn &rest args)
    "Suppress olivetti error messages."
    (let ((inhibit-message t)
          (message-log-max nil))
      (condition-case nil
          (apply orig-fn args)
        (error nil))))
  
  ;; Apply error suppression to the functions that generate errors
  (advice-add 'olivetti-set-window :around #'olivetti--suppress-errors)
  (advice-add 'olivetti-normalize-width :around #'olivetti--suppress-errors)
  
  (auto-olivetti-mode))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
** Modeline
Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

Recent version of [[https://github.com/seagle0128/doom-modeline/pull/622][doom-modeline]] features [[github:rainstormstudio/nerd-icons.el][nerd-icons.el]] instead of [[github:domtronn/all-the-icons.el][all-the-icons.el]].
I like this change, however different parts of Doom are still using =all-the-icons= under the hood.
Some custom configurations is needed for now.

#+begin_src emacs-lisp
(use-package! nerd-icons
  :custom
  (nerd-icons-font-family "FiraMono Nerd Font Mono")
  (nerd-icons-scale-factor 1.2)
  (nerd-icons-default-adjust 0)
  (doom-modeline-major-mode-icon t))
#+end_src

** Narrowing and center buffer contents
On larger screens I like buffer contents to not exceed a certain width and are centered.
=olivetti-mode= solves this problem nicely.
There is also an =auto-olivetti-mode=  which automatically turns on =olivetti-mode= in most buffers.

#+begin_src emacs-lisp
(use-package! olivetti
  :config
  (setq-default olivetti-body-width 130)
  (add-hook 'mixed-pitch-mode-hook  
            (lambda () 
              (when (and (bound-and-true-p olivetti-mode)
                         (or (not (numberp olivetti-body-width))
                             (eq olivetti-body-width 'unspecified)))
                (setq-local olivetti-body-width 90)))))

(use-package! auto-olivetti
  :custom
  (auto-olivetti-enabled-modes '(text-mode prog-mode helpful-mode ibuffer-mode image-mode))
  :config
  ;; Fix for olivetti-body-width being set to 'unspecified
  (defadvice! +olivetti-fix-unspecified-width-a (&rest _)
    "Fix olivetti-body-width when it gets set to 'unspecified."
    :before #'olivetti-set-window
    (when (or (not (numberp olivetti-body-width))
              (eq olivetti-body-width 'unspecified))
      (setq-local olivetti-body-width 130)))
  
  ;; Remove the error handling approach and try a different strategy
  ;; This wrapper suppresses the error messages while preserving functionality
  (defun olivetti--suppress-errors (orig-fn &rest args)
    "Suppress olivetti error messages."
    (let ((inhibit-message t)
          (message-log-max nil))
      (condition-case nil
          (apply orig-fn args)
        (error nil))))
  
  ;; Apply error suppression to the functions that generate errors
  (advice-add 'olivetti-set-window :around #'olivetti--suppress-errors)
  (advice-add 'olivetti-normalize-width :around #'olivetti--suppress-errors)
  
  (auto-olivetti-mode))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
** Modeline
Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

Recent version of [[https://github.com/seagle0128/doom-modeline/pull/622][doom-modeline]] features [[github:rainstormstudio/nerd-icons.el][nerd-icons.el]] instead of [[github:domtronn/all-the-icons.el][all-the-icons.el]].
I like this change, however different parts of Doom are still using =all-the-icons= under the hood.
Some custom configurations is needed for now.

#+begin_src emacs-lisp
(use-package! nerd-icons
  :custom
  (nerd-icons-font-family "FiraMono Nerd Font Mono")
  (nerd-icons-scale-factor 1.2)
  (nerd-icons-default-adjust 0)
  (doom-modeline-major-mode-icon t))
#+end_src

** Narrowing and center buffer contents
On larger screens I like buffer contents to not exceed a certain width and are centered.
=olivetti-mode= solves this problem nicely.
There is also an =auto-olivetti-mode=  which automatically turns on =olivetti-mode= in most buffers.

#+begin_src emacs-lisp
(use-package! olivetti
  :config
  (setq-default olivetti-body-width 130)
  (add-hook 'mixed-pitch-mode-hook  
            (lambda () 
              (when (and (bound-and-true-p olivetti-mode)
                         (or (not (numberp olivetti-body-width))
                             (eq olivetti-body-width 'unspecified)))
                (setq-local olivetti-body-width 90)))))

(use-package! auto-olivetti
  :custom
  (auto-olivetti-enabled-modes '(text-mode prog-mode helpful-mode ibuffer-mode image-mode))
  :config
  ;; Fix for olivetti-body-width being set to 'unspecified
  (defadvice! +olivetti-fix-unspecified-width-a (&rest _)
    "Fix olivetti-body-width when it gets set to 'unspecified."
    :before #'olivetti-set-window
    (when (or (not (numberp olivetti-body-width))
              (eq olivetti-body-width 'unspecified))
      (setq-local olivetti-body-width 130)))
  
  ;; Remove the error handling approach and try a different strategy
  ;; This wrapper suppresses the error messages while preserving functionality
  (defun olivetti--suppress-errors (orig-fn &rest args)
    "Suppress olivetti error messages."
    (let ((inhibit-message t)
          (message-log-max nil))
      (condition-case nil
          (apply orig-fn args)
        (error nil))))
  
  ;; Apply error suppression to the functions that generate errors
  (advice-add 'olivetti-set-window :around #'olivetti--suppress-errors)
  (advice-add 'olivetti-normalize-width :around #'olivetti--suppress-errors)
  
  (auto-olivetti-mode))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
** Modeline
Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

Recent version of [[https://github.com/seagle0128/doom-modeline/pull/622][doom-modeline]] features [[github:rainstormstudio/nerd-icons.el][nerd-icons.el]] instead of [[github:domtronn/all-the-icons.el][all-the-icons.el]].
I like this change, however different parts of Doom are still using =all-the-icons= under the hood.
Some custom configurations is needed for now.

#+begin_src emacs-lisp
(use-package! nerd-icons
  :custom
  (nerd-icons-font-family "FiraMono Nerd Font Mono")
  (nerd-icons-scale-factor 1.2)
  (nerd-icons-default-adjust 0)
  (doom-modeline-major-mode-icon t))
#+end_src

** Narrowing and center buffer contents
On larger screens I like buffer contents to not exceed a certain width and are centered.
=olivetti-mode= solves this problem nicely.
There is also an =auto-olivetti-mode=  which automatically turns on =olivetti-mode= in most buffers.

#+begin_src emacs-lisp
(use-package! olivetti
  :config
  (setq-default olivetti-body-width 130)
  (add-hook 'mixed-pitch-mode-hook  
            (lambda () 
              (when (and (bound-and-true-p olivetti-mode)
                         (or (not (numberp olivetti-body-width))
                             (eq olivetti-body-width 'unspecified)))
                (setq-local olivetti-body-width 90)))))

(use-package! auto-olivetti
  :custom
  (auto-olivetti-enabled-modes '(text-mode prog-mode helpful-mode ibuffer-mode image-mode))
  :config
  ;; Fix for olivetti-body-width being set to 'unspecified
  (defadvice! +olivetti-fix-unspecified-width-a (&rest _)
    "Fix olivetti-body-width when it gets set to 'unspecified."
    :before #'olivetti-set-window
    (when (or (not (numberp olivetti-body-width))
              (eq olivetti-body-width 'unspecified))
      (setq-local olivetti-body-width 130)))
  
  ;; Remove the error handling approach and try a different strategy
  ;; This wrapper suppresses the error messages while preserving functionality
  (defun olivetti--suppress-errors (orig-fn &rest args)
    "Suppress olivetti error messages."
    (let ((inhibit-message t)
          (message-log-max nil))
      (condition-case nil
          (apply orig-fn args)
        (error nil))))
  
  ;; Apply error suppression to the functions that generate errors
  (advice-add 'olivetti-set-window :around #'olivetti--suppress-errors)
  (advice-add 'olivetti-normalize-width :around #'olivetti--suppress-errors)
  
  (auto-olivetti-mode))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
** Modeline
Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

Recent version of [[https://github.com/seagle0128/doom-modeline/pull/622][doom-modeline]] features [[github:rainstormstudio/nerd-icons.el][nerd-icons.el]] instead of [[github:domtronn/all-the-icons.el][all-the-icons.el]].
I like this change, however different parts of Doom are still using =all-the-icons= under the hood.
Some custom configurations is needed for now.

#+begin_src emacs-lisp
(use-package! nerd-icons
  :custom
  (nerd-icons-font-family "FiraMono Nerd Font Mono")
  (nerd-icons-scale-factor 1.2)
  (nerd-icons-default-adjust 0)
  (doom-modeline-major-mode-icon t))
#+end_src

** Narrowing and center buffer contents
On larger screens I like buffer contents to not exceed a certain width and are centered.
=olivetti-mode= solves this problem nicely.
There is also an =auto-olivetti-mode=  which automatically turns on =olivetti-mode= in most buffers.

#+begin_src emacs-lisp
(use-package! olivetti
  :config
  (setq-default olivetti-body-width 130)
  (add-hook 'mixed-pitch-mode-hook  
            (lambda () 
              (when (and (bound-and-true-p olivetti-mode)
                         (or (not (numberp olivetti-body-width))
                             (eq olivetti-body-width 'unspecified)))
                (setq-local olivetti-body-width 90)))))

(use-package! auto-olivetti
  :custom
  (auto-olivetti-enabled-modes '(text-mode prog-mode helpful-mode ibuffer-mode image-mode))
  :config
  ;; Fix for olivetti-body-width being set to 'unspecified
  (defadvice! +olivetti-fix-unspecified-width-a (&rest _)
    "Fix olivetti-body-width when it gets set to 'unspecified."
    :before #'olivetti-set-window
    (when (or (not (numberp olivetti-body-width))
              (eq olivetti-body-width 'unspecified))
      (setq-local olivetti-body-width 130)))
  
  ;; Remove the error handling approach and try a different strategy
  ;; This wrapper suppresses the error messages while preserving functionality
  (defun olivetti--suppress-errors (orig-fn &rest args)
    "Suppress olivetti error messages."
    (let ((inhibit-message t)
          (message-log-max nil))
      (condition-case nil
          (apply orig-fn args)
        (error nil))))
  
  ;; Apply error suppression to the functions that generate errors
  (advice-add 'olivetti-set-window :around #'olivetti--suppress-errors)
  (advice-add 'olivetti-normalize-width :around #'olivetti--suppress-errors)
  
  (auto-olivetti-mode))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
** Modeline
Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

Recent version of [[https://github.com/seagle0128/doom-modeline/pull/622][doom-modeline]] features [[github:rainstormstudio/nerd-icons.el][nerd-icons.el]] instead of [[github:domtronn/all-the-icons.el][all-the-icons.el]].
I like this change, however different parts of Doom are still using =all-the-icons= under the hood.
Some custom configurations is needed for now.

#+begin_src emacs-lisp
(use-package! nerd-icons
  :custom
  (nerd-icons-font-family "FiraMono Nerd Font Mono")
  (nerd-icons-scale-factor 1.2)
  (nerd-icons-default-adjust 0)
  (doom-modeline-major-mode-icon t))
#+end_src

** Narrowing and center buffer contents
On larger screens I like buffer contents to not exceed a certain width and are centered.
=olivetti-mode= solves this problem nicely.
There is also an =auto-olivetti-mode=  which automatically turns on =olivetti-mode= in most buffers.

#+begin_src emacs-lisp
(use-package! olivetti
  :config
  (setq-default olivetti-body-width 130)
  (add-hook 'mixed-pitch-mode-hook  
            (lambda () 
              (when (and (bound-and-true-p olivetti-mode)
                         (or (not (numberp olivetti-body-width))
                             (eq olivetti-body-width 'unspecified)))
                (setq-local olivetti-body-width 90)))))

(use-package! auto-olivetti
  :custom
  (auto-olivetti-enabled-modes '(text-mode prog-mode helpful-mode ibuffer-mode image-mode))
  :config
  ;; Fix for olivetti-body-width being set to 'unspecified
  (defadvice! +olivetti-fix-unspecified-width-a (&rest _)
    "Fix olivetti-body-width when it gets set to 'unspecified."
    :before #'olivetti-set-window
    (when (or (not (numberp olivetti-body-width))
              (eq olivetti-body-width 'unspecified))
      (setq-local olivetti-body-width 130)))
  
  ;; Remove the error handling approach and try a different strategy
  ;; This wrapper suppresses the error messages while preserving functionality
  (defun olivetti--suppress-errors (orig-fn &rest args)
    "Suppress olivetti error messages."
    (let ((inhibit-message t)
          (message-log-max nil))
      (condition-case nil
          (apply orig-fn args)
        (error nil))))
  
  ;; Apply error suppression to the functions that generate errors
  (advice-add 'olivetti-set-window :around #'olivetti--suppress-errors)
  (advice-add 'olivetti-normalize-width :around #'olivetti--suppress-errors)
  
  (auto-olivetti-mode))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
** Modeline
Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

Recent version of [[https://github.com/seagle0128/doom-modeline/pull/622][doom-modeline]] features [[github:rainstormstudio/nerd-icons.el][nerd-icons.el]] instead of [[github:domtronn/all-the-icons.el][all-the-icons.el]].
I like this change, however different parts of Doom are still using =all-the-icons= under the hood.
Some custom configurations is needed for now.

#+begin_src emacs-lisp
(use-package! nerd-icons
  :custom
  (nerd-icons-font-family "FiraMono Nerd Font Mono")
  (nerd-icons-scale-factor 1.2)
  (nerd-icons-default-adjust 0)
  (doom-modeline-major-mode-icon t))
#+end_src

** Narrowing and center buffer contents
On larger screens I like buffer contents to not exceed a certain width and are centered.
=olivetti-mode= solves this problem nicely.
There is also an =auto-olivetti-mode=  which automatically turns on =olivetti-mode= in most buffers.

#+begin_src emacs-lisp
(use-package! olivetti
  :config
  (setq-default olivetti-body-width 130)
  (add-hook 'mixed-pitch-mode-hook  
            (lambda () 
              (when (and (bound-and-true-p olivetti-mode)
                         (or (not (numberp olivetti-body-width))
                             (eq olivetti-body-width 'unspecified)))
                (setq-local olivetti-body-width 90)))))

(use-package! auto-olivetti
  :custom
  (auto-olivetti-enabled-modes '(text-mode prog-mode helpful-mode ibuffer-mode image-mode))
  :config
  ;; Fix for olivetti-body-width being set to 'unspecified
  (defadvice! +olivetti-fix-unspecified-width-a (&rest _)
    "Fix olivetti-body-width when it gets set to 'unspecified."
    :before #'olivetti-set-window
    (when (or (not (numberp olivetti-body-width))
              (eq olivetti-body-width 'unspecified))
      (setq-local olivetti-body-width 130)))
  
  ;; Remove the error handling approach and try a different strategy
  ;; This wrapper suppresses the error messages while preserving functionality
  (defun olivetti--suppress-errors (orig-fn &rest args)
    "Suppress olivetti error messages."
    (let ((inhibit-message t)
          (message-log-max nil))
      (condition-case nil
          (apply orig-fn args)
        (error nil))))
  
  ;; Apply error suppression to the functions that generate errors
  (advice-add 'olivetti-set-window :around #'olivetti--suppress-errors)
  (advice-add 'olivetti-normalize-width :around #'olivetti--suppress-errors)
  
  (auto-olivetti-mode))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
* Modeline
** Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

Recent version of [[https://github.com/seagle0128/doom-modeline/pull/622][doom-modeline]] features [[github:rainstormstudio/nerd-icons.el][nerd-icons.el]] instead of [[github:domtronn/all-the-icons.el][all-the-icons.el]].
I like this change, however different parts of Doom are still using =all-the-icons= under the hood.
Some custom configurations is needed for now.

#+begin_src emacs-lisp
(use-package! nerd-icons
  :custom
  (nerd-icons-font-family "FiraMono Nerd Font Mono")
  (nerd-icons-scale-factor 1.2)
  (nerd-icons-default-adjust 0)
  (doom-modeline-major-mode-icon t))
#+end_src

** Narrowing and center buffer contents
On larger screens I like buffer contents to not exceed a certain width and are centered.
=olivetti-mode= solves this problem nicely.
There is also an =auto-olivetti-mode=  which automatically turns on =olivetti-mode= in most buffers.

#+begin_src emacs-lisp
(use-package! olivetti
  :config
  (setq-default olivetti-body-width 130)
  (add-hook 'mixed-pitch-mode-hook  
            (lambda () 
              (when (and (bound-and-true-p olivetti-mode)
                         (or (not (numberp olivetti-body-width))
                             (eq olivetti-body-width 'unspecified)))
                (setq-local olivetti-body-width 90)))))

(use-package! auto-olivetti
  :custom
  (auto-olivetti-enabled-modes '(text-mode prog-mode helpful-mode ibuffer-mode image-mode))
  :config
  ;; Fix for olivetti-body-width being set to 'unspecified
  (defadvice! +olivetti-fix-unspecified-width-a (&rest _)
    "Fix olivetti-body-width when it gets set to 'unspecified."
    :before #'olivetti-set-window
    (when (or (not (numberp olivetti-body-width))
              (eq olivetti-body-width 'unspecified))
      (setq-local olivetti-body-width 130)))
  
  ;; Remove the error handling approach and try a different strategy
  ;; This wrapper suppresses the error messages while preserving functionality
  (defun olivetti--suppress-errors (orig-fn &rest args)
    "Suppress olivetti error messages."
    (let ((inhibit-message t)
          (message-log-max nil))
      (condition-case nil
          (apply orig-fn args)
        (error nil))))
  
  ;; Apply error suppression to the functions that generate errors
  (advice-add 'olivetti-set-window :around #'olivetti--suppress-errors)
  (advice-add 'olivetti-normalize-width :around #'olivetti--suppress-errors)
  
  (auto-olivetti-mode))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
** Modeline
Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

Recent version of [[https://github.com/seagle0128/doom-modeline/pull/622][doom-modeline]] features [[github:rainstormstudio/nerd-icons.el][nerd-icons.el]] instead of [[github:domtronn/all-the-icons.el][all-the-icons.el]].
I like this change, however different parts of Doom are still using =all-the-icons= under the hood.
Some custom configurations is needed for now.

#+begin_src emacs-lisp
(use-package! nerd-icons
  :custom
  (nerd-icons-font-family "FiraMono Nerd Font Mono")
  (nerd-icons-scale-factor 1.2)
  (nerd-icons-default-adjust 0)
  (doom-modeline-major-mode-icon t))
#+end_src

** Narrowing and center buffer contents
On larger screens I like buffer contents to not exceed a certain width and are centered.
=olivetti-mode= solves this problem nicely.
There is also an =auto-olivetti-mode=  which automatically turns on =olivetti-mode= in most buffers.

#+begin_src emacs-lisp
(use-package! olivetti
  :config
  (setq-default olivetti-body-width 130)
  (add-hook 'mixed-pitch-mode-hook  
            (lambda () 
              (when (and (bound-and-true-p olivetti-mode)
                         (or (not (numberp olivetti-body-width))
                             (eq olivetti-body-width 'unspecified)))
                (setq-local olivetti-body-width 90)))))

(use-package! auto-olivetti
  :custom
  (auto-olivetti-enabled-modes '(text-mode prog-mode helpful-mode ibuffer-mode image-mode))
  :config
  ;; Fix for olivetti-body-width being set to 'unspecified
  (defadvice! +olivetti-fix-unspecified-width-a (&rest _)
    "Fix olivetti-body-width when it gets set to 'unspecified."
    :before #'olivetti-set-window
    (when (or (not (numberp olivetti-body-width))
              (eq olivetti-body-width 'unspecified))
      (setq-local olivetti-body-width 130)))
  
  ;; Remove the error handling approach and try a different strategy
  ;; This wrapper suppresses the error messages while preserving functi onality
  (defun olivetti--suppress-errors (orig-fn &rest args)
    "Suppress olivetti error messages."
    (let ((inhibit-message t)
          (message-log-max nil))
      (condition-case nil
          (apply orig-fn args)
        (error nil))))
  
  ;; Apply error suppression to the functions that generate errors
  (advice-add 'olivetti-set-window :around #'olivetti--suppress-errors)
  (advice-add 'olivetti-normalize-width :around #'olivetti--suppress-errors)
  
  (auto-olivetti-mode))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
** Modeline
Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

Recent version of [[https://github.com/seagle0128/doom-modeline/pull/622][doom-modeline]] features [[github:rainstormstudio/nerd-icons.el][nerd-icons.el]] instead of [[github:domtronn/all-the-icons.el][all-the-icons.el]].
I like this change, however different parts of Doom are still using =all-the-icons= under the hood.
Some custom configurations is needed for now.

#+begin_src emacs-lisp
(use-package! nerd-icons
  :custom
  (nerd-icons-font-family "FiraMono Nerd Font Mono")
  (nerd-icons-scale-factor 1.2)
  (nerd-icons-default-adjust 0)
  (doom-modeline-major-mode-icon t))
#+end_src

** Narrowing and center buffer contents
On larger screens I like buffer contents to not exceed a certain width and are centered.
=olivetti-mode= solves this problem nicely.
There is also an =auto-olivetti-mode=  which automatically turns on =olivetti-mode= in most buffers.

#+begin_src emacs-lisp
(use-package! olivetti
  :config
  (setq-default olivetti-body-width 130)
  (add-hook 'mixed-pitch-mode-hook  
            (lambda () 
              (when (and (bound-and-true-p olivetti-mode)
                         (or (not (numberp olivetti-body-width))
                             (eq olivetti-body-width 'unspecified)))
                (setq-local olivetti-body-width 90)))))

(use-package! auto-olivetti
  :custom
  (auto-olivetti-enabled-modes '(text-mode prog-mode helpful-mode ibuffer-mode image-mode))
  :config
  ;; Fix for olivetti-body-width being set to 'unspecified
  (defadvice! +olivetti-fix-unspecified-width-a (&rest _)
    "Fix olivetti-body-width when it gets set to 'unspecified."
    :before #'olivetti-set-window
    (when (or (not (numberp olivetti-body-width))
              (eq olivetti-body-width 'unspecified))
      (setq-local olivetti-body-width 130)))
  
  ;; Remove the error handling approach and try a different strategy
  ;; This wrapper suppresses the error messages while preserving functionality
  (defun olivetti--suppress-errors (orig-fn &rest args)
    "Suppress olivetti error messages."
    (let ((inhibit-message t)
          (message-log-max nil))
      (condition-case nil
          (apply orig-fn args)
        (error nil))))
  
  ;; Apply error suppression to the functions that generate errors
  (advice-add 'olivetti-set-window :around #'olivetti--suppress-errors)
  (advice-add 'olivetti-normalize-width :around #'olivetti--suppress-errors)
  
  (auto-olivetti-mode))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
** Modeline
Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun hp/org-roam-calculate-similarity (node-id-1 node-id-2)
  "Calculate similarity between two nodes based on shared links and tags."
  (let* ((node1 (org-roam-node-from-id node-id-1))
         (node2 (org-roam-node-from-id node-id-2))
         (tags1 (org-roam-node-tags node1))
         (tags2 (org-roam-node-tags node2))
         (shared-tags (seq-intersection tags1 tags2))
         (tag-similarity (if (or (null tags1) (null tags2))
                            0.0
                          (/ (float (length shared-tags))
                             (length (seq-uniq (append tags1 tags2))))))
         ;; Get backlinks for both nodes
         (backlinks1 (org-roam-db-query
                     [:select [source]
                      :from links
                      :where (= dest $s1)]
                     node-id-1))
         (backlinks2 (org-roam-db-query
                     [:select [source]
                      :from links
                      :where (= dest $s1)]
                     node-id-2))
         (shared-backlinks (seq-intersection (mapcar #'car backlinks1)
                                           (mapcar #'car backlinks2)))
         (backlink-similarity (if (and backlinks1 backlinks2)
                                 (/ (float (length shared-backlinks))
                                    (length (seq-uniq (append (mapcar #'car backlinks1)
                                                            (mapcar #'car backlinks2)))))
                               0.0))
         ;; Get forward links
         (links1 (org-roam-db-query
                 [:select [dest]
                  :from links
                  :where (= source $s1)]
                 node-id-1))
         (links2 (org-roam-db-query
                 [:select [dest]
                  :from links
                  :where (= source $s1)]
                 node-id-2))
         (shared-links (seq-intersection (mapcar #'car links1)
                                       (mapcar #'car links2)))
         (link-similarity (if (and links1 links2)
                             (/ (float (length shared-links))
                                (length (seq-uniq (append (mapcar #'car links1)
                                                        (mapcar #'car links2)))))
                           0.0)))
    ;; Weighted average of similarities
    (+ (* 0.4 tag-similarity)
       (* 0.3 backlink-similarity)
       (* 0.3 link-similarity))))

(defun hp/org-roam-find-similar-nodes ()
  "Find nodes similar to the current node based on content and connections."
  (interactive)
  (let* ((current-node (org-roam-node-at-point))
         (threshold 0.3))
    (if current-node
        (let* ((current-id (org-roam-node-id current-node))
               (all-nodes (org-roam-node-list))
               (similar-nodes '()))
          (dolist (node all-nodes)
            (unless (string= (org-roam-node-id node) current-id)
              (let ((similarity (hp/org-roam-calculate-similarity current-id (org-roam-node-id node))))
                (when (> similarity threshold)
                  (push (cons similarity node) similar-nodes)))))
          (setq similar-nodes (sort similar-nodes (lambda (a b) (> (car a) (car b)))))
          (if similar-nodes
              (let ((buffer (get-buffer-create "*Similar Nodes*")))
                (with-current-buffer buffer
                  (erase-buffer)
                  (insert (format "# Nodes similar to: %s\n\n" (org-roam-node-title current-node)))
                  (dolist (item (seq-take similar-nodes 20))
                    (let ((sim (car item))
                          (node (cdr item)))
                      (insert (format "- [[id:%s][%s]] (%.2f)\n"
                                     (org-roam-node-id node)
                                     (org-roam-node-title node)
                                     sim))))
                  (org-mode)
                  (goto-char (point-min)))
                (pop-to-buffer buffer))
            (message "No similar nodes found above threshold %.2f" threshold)))
      (message "No node at point"))))

(defun hp/org-roam-cluster-analysis ()
  "Perform cluster analysis on all org-roam nodes."
  (interactive)
  (let* ((all-nodes (org-roam-node-list))
         (clusters (make-hash-table :test 'equal))
         (processed-pairs (make-hash-table :test 'equal)))
    (message "Analyzing %d nodes for clustering..." (length all-nodes))
    (dotimes (i (length all-nodes))
      (let ((node1 (nth i all-nodes)))
        (dotimes (j (length all-nodes))
          (when (and (not (= i j))
                     (not (gethash (format "%s-%s" 
                                          (min i j) (max i j)) processed-pairs)))
            (let* ((node2 (nth j all-nodes))
                   (similarity (hp/org-roam-calculate-similarity 
                               (org-roam-node-id node1) 
                               (org-roam-node-id node2))))
              (puthash (format "%s-%s" (min i j) (max i j)) t processed-pairs)
              (when (> similarity 0.4)  ; Clustering threshold
                (let ((cluster-key (format "cluster-%d" (min i j))))
                  (unless (gethash cluster-key clusters)
                    (puthash cluster-key '() clusters))
                  (puthash cluster-key 
                          (cons node1 (cons node2 (gethash cluster-key clusters)))
                          clusters))))))))
    (let ((buffer (get-buffer-create "*Node Clusters*")))
      (with-current-buffer buffer
        (erase-buffer)
        (insert "# Node Clustering Analysis\n\n")
        (maphash (lambda (cluster-key nodes)
                   (let ((unique-nodes (delete-dups nodes)))
                     (when (> (length unique-nodes) 1)
                       (insert (format "## %s (%d nodes)\n\n" 
                                      cluster-key (length unique-nodes)))
                       (dolist (node unique-nodes)
                         (insert (format "- [[id:%s][%s]]\n"
                                        (org-roam-node-id node)
                                        (org-roam-node-title node))))
                       (insert "\n"))))
                 clusters)
        (org-mode)
        (goto-char (point-min)))
      (pop-to-buffer buffer))))

;; Hash table to store tag frequency weights
(defvar hp/org-roam-tag-weights (make-hash-table :test 'equal)
  "Hash table storing tag frequencies for clustering.")

(defun hp/org-roam-update-tag-weights ()
  "Update tag frequency weights for better clustering."
  (interactive)
  (clrhash hp/org-roam-tag-weights)
  (let ((all-nodes (org-roam-node-list)))
    (dolist (node all-nodes)
      (dolist (tag (org-roam-node-tags node))
        (puthash tag (1+ (gethash tag hp/org-roam-tag-weights 0)) 
                hp/org-roam-tag-weights)))
    (message "Updated tag weights for %d unique tags" 
             (hash-table-count hp/org-roam-tag-weights))))

;; Initialize tag weights on startup
(run-with-idle-timer 5 nil #'hp/org-roam-update-tag-weights)
#+end_src

***** Time-Based Link Decay & Refresh System

#+begin_src emacs-lisp
;; Time-based link decay and refresh system for org-roam
(defvar hp/org-roam-link-decay-threshold 90
  "Number of days after which a link is considered stale.")

(defvar hp/org-roam-link-refresh-threshold 30
  "Number of days after which to suggest refreshing content.")

(defvar hp/org-roam-decay-weights
  '((30 . 1.0)    ; Fresh (within 30 days)
    (60 . 0.8)    ; Recent (30-60 days)
    (90 . 0.6)    ; Aging (60-90 days)
    (180 . 0.4)   ; Stale (90-180 days)
    (365 . 0.2)   ; Old (180-365 days)
    (1000 . 0.1)) ; Ancient (>365 days)
  "Weight multipliers based on link age in days.")

(defun hp/org-roam-calculate-link-age (file-path)
  "Calculate the age of a file in days."
  (let* ((file-time (file-attribute-modification-time (file-attributes file-path)))
         (current-time (current-time))
         (time-diff (time-subtract current-time file-time)))
    (/ (float-time time-diff) 86400))) ; Convert to days

(defun hp/org-roam-get-decay-weight (age-days)
  "Get the decay weight for a given age in days."
  (let ((weight 0.1)) ; Default weight for very old content
    (dolist (threshold-weight hp/org-roam-decay-weights)
      (when (<= age-days (car threshold-weight))
        (setq weight (cdr threshold-weight))
        (return)))
    weight))

(defun hp/org-roam-find-stale-links ()
  "Find all stale links in the org-roam database."
  (interactive)
  (let* ((all-nodes (org-roam-node-list))
         (stale-nodes '())
         (refresh-nodes '()))
    (dolist (node all-nodes)
      (let* ((file-path (org-roam-node-file node))
             (age-days (hp/org-roam-calculate-link-age file-path)))
        (cond
         ((> age-days hp/org-roam-link-decay-threshold)
          (push (cons age-days node) stale-nodes))
         ((> age-days hp/org-roam-link-refresh-threshold)
          (push (cons age-days node) refresh-nodes)))))
    
    (let ((buffer (get-buffer-create "*Stale Links Analysis*")))
      (with-current-buffer buffer
        (erase-buffer)
        (insert "# Link Decay Analysis\n\n")
        
        (when stale-nodes
          (insert (format "## Stale Nodes (>%d days old)\n\n" hp/org-roam-link-decay-threshold))
          (dolist (stale-node (sort stale-nodes (lambda (a b) (> (car a) (car b)))))
            (let ((age (car stale-node))
                  (node (cdr stale-node)))
              (insert (format "**%d days old** - [[id:%s][%s]]\n"
                             (round age)
                             (org-roam-node-id node)
                             (org-roam-node-title node)))))
          (insert "\n"))
        
        (when refresh-nodes
          (insert (format "## Nodes Needing Refresh (>%d days old)\n\n" hp/org-roam-link-refresh-threshold))
          (dolist (refresh-node (sort refresh-nodes (lambda (a b) (> (car a) (car b)))))
            (let ((age (car refresh-node))
                  (node (cdr refresh-node)))
              (insert (format "**%d days old** - [[id:%s][%s]]\n"
                             (round age)
                             (org-roam-node-id node)
                             (org-roam-node-title node)))))
          (insert "\n"))
        
        (insert (format "\n## Summary\n- Stale nodes: %d\n- Nodes needing refresh: %d\n- Total analyzed: %d"
                       (length stale-nodes) (length refresh-nodes) (length all-nodes)))
        (org-mode)
        (goto-char (point-min)))
      (pop-to-buffer buffer))))

(defun hp/org-roam-refresh-node-timestamp ()
  "Refresh the timestamp of the current node."
  (interactive)
  (when-let ((node (org-roam-node-at-point)))
    (save-excursion
      (goto-char (point-min))
      (if (re-search-forward "^#\\+created:" nil t)
          (progn
            (beginning-of-line)
            (kill-line)
            (insert (format "#+created: %s" (format-time-string "[%Y-%m-%d %a %H:%M]"))))
        (progn
          (goto-char (point-min))
          (when (re-search-forward "^#\\+title:" nil t)
            (end-of-line)
            (insert (format "\n#+created: %s" (format-time-string "[%Y-%m-%d %a %H:%M]"))))))
      ;; Also add a last-modified timestamp
      (goto-char (point-min))
      (if (re-search-forward "^#\\+modified:" nil t)
          (progn
            (beginning-of-line)
            (kill-line)
            (insert (format "#+modified: %s" (format-time-string "[%Y-%m-%d %a %H:%M]"))))
        (progn
          (goto-char (point-min))
          (when (re-search-forward "^#\\+created:" nil t)
            (end-of-line)
            (insert (format "\n#+modified: %s" (format-time-string "[%Y-%m-%d %a %H:%M]")))))))
    (org-roam-db-sync)
    (message "Refreshed timestamps for: %s" (org-roam-node-title node))))

(defun hp/org-roam-weighted-node-search ()
  "Search nodes with time-based decay weighting."
  (interactive)
  (let* ((all-nodes (org-roam-node-list))
         (weighted-nodes '()))
    (dolist (node all-nodes)
      (let* ((file-path (org-roam-node-file node))
             (age-days (hp/org-roam-calculate-link-age file-path))
             (weight (hp/org-roam-get-decay-weight age-days))
             (weighted-title (format "[%.1f] %s" weight (org-roam-node-title node))))
        (push (cons weighted-title node) weighted-nodes)))
    
    (let* ((sorted-nodes (sort weighted-nodes 
                              (lambda (a b) 
                                (let ((weight-a (string-to-number (substring (car a) 1 4)))
                                      (weight-b (string-to-number (substring (car b) 1 4))))
                                  (> weight-a weight-b)))))
           (selected (completing-read "Select node (time-weighted): " 
                                     (mapcar #'car sorted-nodes)))
           (node (cdr (assoc selected sorted-nodes))))
      (org-roam-node-visit node))))

(defun hp/org-roam-schedule-refresh-reminders ()
  "Schedule refresh reminders for aging content."
  (interactive)
  (let* ((all-nodes (org-roam-node-list))
         (reminder-count 0))
    (dolist (node all-nodes)
      (let* ((file-path (org-roam-node-file node))
             (age-days (hp/org-roam-calculate-link-age file-path)))
        (when (and (> age-days hp/org-roam-link-refresh-threshold)
                   (< age-days hp/org-roam-link-decay-threshold))
          (setq reminder-count (1+ reminder-count))
          ;; Could integrate with org-agenda or notification system here
          )))
    (message "Scheduled %d refresh reminders" reminder-count)))

(defface hp/org-roam-stale-link-face
  '((t (:foreground "#888888" :slant italic)))
  "Face for stale org-roam links.")

(defface hp/org-roam-fresh-link-face
  '((t (:foreground "#4CAF50" :weight bold)))
  "Face for fresh org-roam links.")

(defun hp/org-roam-colorize-links-by-age ()
  "Colorize org-roam links based on their age."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "\\[\\[id:\\([^]]+\\)\\]\\[\\([^]]+\\)\\]\\]" nil t)
      (let* ((node-id (match-string 1))
             (node (org-roam-node-from-id node-id))
             (overlay (make-overlay (match-beginning 0) (match-end 0))))
        (when node
          (let* ((file-path (org-roam-node-file node))
                 (age-days (hp/org-roam-calculate-link-age file-path))
                 (face (cond
                        ((< age-days 30) 'hp/org-roam-fresh-link-face)
                        ((> age-days hp/org-roam-link-decay-threshold) 'hp/org-roam-stale-link-face)
                        (t 'default))))
            (overlay-put overlay 'face face)
            (overlay-put overlay 'help-echo 
                        (format "Age: %d days, Weight: %.1f" 
                               (round age-days)
                               (hp/org-roam-get-decay-weight age-days)))))))))

(defun hp/org-roam-cleanup-stale-content ()
  "Interactive cleanup of stale content."
  (interactive)
  (let* ((all-nodes (org-roam-node-list))
         (stale-nodes '()))
    (dolist (node all-nodes)
      (let* ((file-path (org-roam-node-file node))
             (age-days (hp/org-roam-calculate-link-age file-path)))
        (when (> age-days hp/org-roam-link-decay-threshold)
          (push (cons age-days node) stale-nodes))))
    
    (if stale-nodes
        (progn
          (message "Found %d stale nodes" (length stale-nodes))
          (dolist (stale-node (sort stale-nodes (lambda (a b) (> (car a) (car b)))))
            (let* ((age (car stale-node))
                   (node (cdr stale-node))
                   (title (org-roam-node-title node)))
              (when (y-or-n-p (format "Archive/refresh %s (%d days old)? " title (round age)))
                (org-roam-node-visit node)
                (hp/org-roam-refresh-node-timestamp)
                (message "Refreshed: %s" title)))))
      (message "No stale content found"))))

;; Auto-colorize links in org-roam buffers
(add-hook 'org-roam-mode-hook #'hp/org-roam-colorize-links-by-age)
#+end_src

***** Enhanced Capture with Context Awareness

#+begin_src emacs-lisp
;; Context-aware capture system for org-roam
(defvar hp/org-roam-context-buffer "*Org-Roam Context*"
  "Buffer name for displaying capture context.")

(defvar hp/org-roam-capture-context-history '()
  "History of recent capture contexts.")

(defun hp/org-roam-get-current-context ()
  "Get the current context for capture (current file, project, etc.)."
  (let ((context '()))
    ;; Current file context
    (when buffer-file-name
      (push (cons "current-file" (file-name-base buffer-file-name)) context))
    
    ;; Current org-roam node context
    (when-let ((node (org-roam-node-at-point)))
      (push (cons "current-node" (org-roam-node-title node)) context)
      (push (cons "current-node-id" (org-roam-node-id node)) context)
      (push (cons "current-tags" (org-roam-node-tags node)) context))
    
    ;; Project context (if using projectile)
    (when (and (bound-and-true-p projectile-mode) (projectile-project-p))
      (push (cons "project" (projectile-project-name)) context))
    
    ;; Time context
    (push (cons "time-of-day" 
                (cond 
                 ((< (string-to-number (format-time-string "%H")) 12) "morning")
                 ((< (string-to-number (format-time-string "%H")) 17) "afternoon")
                 (t "evening"))) context)
    
    ;; Day context
    (push (cons "day-of-week" (downcase (format-time-string "%A"))) context)
    
    context))

(defun hp/org-roam-suggest-tags-from-context (context)
  "Suggest tags based on capture context."
  (let ((suggested-tags '()))
    (dolist (ctx context)
      (let ((key (car ctx))
            (value (cdr ctx)))
        (cond
         ((string= key "project")
          (push "project" suggested-tags))
         ((string= key "current-tags")
          (when (listp value)
            (setq suggested-tags (append suggested-tags value))))
         ((string= key "time-of-day")
          (when (member value '("morning" "evening"))
            (push "reflection" suggested-tags)))
         ((string= key "day-of-week")
          (when (member value '("saturday" "sunday"))
            (push "personal" suggested-tags))))))
    (delete-dups suggested-tags)))

(defun hp/org-roam-suggest-links-from-context (context)
  "Suggest related nodes based on context."
  (let ((suggested-links '())
        (current-node-id (cdr (assoc "current-node-id" context)))
        (current-tags (cdr (assoc "current-tags" context))))
    
    ;; Find nodes with similar tags
    (when current-tags
      (let ((similar-nodes (org-roam-db-query
                           "SELECT DISTINCT nodes.id, nodes.title 
                            FROM nodes 
                            JOIN tags ON nodes.id = tags.node_id 
                            WHERE tags.tag IN (%s) AND nodes.id != ?"
                           (mapconcat (lambda (tag) (format "'%s'" tag)) current-tags ",")
                           (or current-node-id ""))))
        (dolist (node similar-nodes)
          (push (cons (nth 1 node) (nth 0 node)) suggested-links))))
    
    (seq-take suggested-links 5))) ; Limit to 5 suggestions

(defun hp/org-roam-enhanced-capture ()
  "Enhanced capture with context awareness."
  (interactive)
  (let* ((context (hp/org-roam-get-current-context))
         (suggested-tags (hp/org-roam-suggest-tags-from-context context))
         (suggested-links (hp/org-roam-suggest-links-from-context context))
         (capture-type (completing-read "Capture type: " 
                                       '("note" "idea" "question" "meeting" "task" "research"))))
    
    ;; Store context for use in capture template
    (setq hp/org-roam-current-capture-context context)
    (setq hp/org-roam-current-suggested-tags suggested-tags)
    (setq hp/org-roam-current-suggested-links suggested-links)
    (setq hp/org-roam-current-capture-type capture-type)
    
    ;; Display context information
    (hp/org-roam-show-capture-context context suggested-tags suggested-links)
    
    ;; Launch appropriate capture template
    (cond
     ((string= capture-type "meeting")
      (org-roam-capture- :keys "m"))
     ((string= capture-type "research")
      (org-roam-capture- :keys "r"))
     ((string= capture-type "task")
      (org-roam-capture- :keys "t"))
     ((string= capture-type "question")
      (org-roam-capture- :keys "q"))
     (t (org-roam-capture- :keys "c"))))) ; Enhanced default

(defun hp/org-roam-show-capture-context (context suggested-tags suggested-links)
  "Display capture context in a side buffer."
  (let ((buffer (get-buffer-create hp/org-roam-context-buffer)))
    (with-current-buffer buffer
      (erase-buffer)
      (insert "# Capture Context\n\n")
      
      (insert "## Current Context\n")
      (dolist (ctx context)
        (insert (format "- **%s**: %s\n" (car ctx) (cdr ctx))))
      
      (when suggested-tags
        (insert "\n## Suggested Tags\n")
        (dolist (tag suggested-tags)
          (insert (format "- %s\n" tag))))
      
      (when suggested-links
        (insert "\n## Related Notes\n")
        (dolist (link suggested-links)
          (insert (format "- [[id:%s][%s]]\n" (cdr link) (car link)))))
      
      (org-mode)
      (goto-char (point-min)))
    
    ;; Show in side window
    (display-buffer buffer '((display-buffer-in-side-window)
                            (side . right)
                            (window-width . 0.3)))))

(defun hp/org-roam-insert-context-template ()
  "Insert context-aware template content."
  (when (bound-and-true-p hp/org-roam-current-capture-context)
    (let ((current-node (cdr (assoc "current-node" hp/org-roam-current-capture-context)))
          (project (cdr (assoc "project" hp/org-roam-current-capture-context)))
          (suggested-links hp/org-roam-current-suggested-links))
      
      (when current-node
        (insert (format "\n** Context\nRelated to: [[id:%s][%s]]\n\n" 
                       (cdr (assoc "current-node-id" hp/org-roam-current-capture-context))
                       current-node)))
      
      (when project
        (insert (format "Project: %s\n\n" project)))
      
      (when suggested-links
        (insert "** Related Notes\n")
        (dolist (link (seq-take suggested-links 3))
          (insert (format "- [[id:%s][%s]]\n" (cdr link) (car link))))
        (insert "\n")))))

(defun hp/org-roam-get-suggested-tags-for-template ()
  "Get suggested tags for use in capture templates."
  (if (bound-and-true-p hp/org-roam-current-suggested-tags)
      (string-join hp/org-roam-current-suggested-tags " ")
    ""))

(defvar hp/org-roam-current-capture-context nil)
(defvar hp/org-roam-current-suggested-tags nil)
(defvar hp/org-roam-current-suggested-links nil)
(defvar hp/org-roam-current-capture-type nil)
#+end_src

***** Capture templates
#+begin_src emacs-lisp
(use-package! org-roam-capture
  :config
  (setq org-roam-capture-templates
        `(("d" "default" plain "%?"
           :target
           (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                      "#+title: ${title}\n#+created: %U\n#+filetags: %(completing-read \"Function tags: \" hp/org-roam-function-tags)\n#+startup: overview")
           :unnarrowed t)
          ("c" "context-aware" plain "%(hp/org-roam-insert-context-template)%?"
           :target
           (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                      "#+title: ${title}\n#+created: %U\n#+filetags: %(hp/org-roam-get-suggested-tags-for-template)\n#+context: %(cdr (assoc \"capture-type\" hp/org-roam-current-capture-context))\n#+startup: overview")
           :unnarrowed t)
          ("m" "meeting" plain "** Attendees\n- \n\n** Agenda\n%?\n\n** Notes\n\n** Action Items\n- [ ] \n\n%(hp/org-roam-insert-context-template)"
           :target
           (file+head "%<%Y%m%d%H%M%S>-meeting-${slug}.org"
                      "#+title: Meeting: ${title}\n#+created: %U\n#+filetags: meeting %(hp/org-roam-get-suggested-tags-for-template)\n#+startup: overview")
           :unnarrowed t)
          ("r" "research" plain "** Research Question\n%?\n\n** Methodology\n\n** Findings\n\n** References\n\n%(hp/org-roam-insert-context-template)"
           :target
           (file+head "%<%Y%m%d%H%M%S>-research-${slug}.org"
                      "#+title: Research: ${title}\n#+created: %U\n#+filetags: research %(hp/org-roam-get-suggested-tags-for-template)\n#+startup: overview")
           :unnarrowed t)
          ("t" "task" plain "** Description\n%?\n\n** Requirements\n\n** Progress\n- [ ] \n\n%(hp/org-roam-insert-context-template)"
           :target
           (file+head "%<%Y%m%d%H%M%S>-task-${slug}.org"
                      "#+title: Task: ${title}\n#+created: %U\n#+filetags: task %(hp/org-roam-get-suggested-tags-for-template)\n#+startup: overview")
           :unnarrowed t)
          ("q" "question" plain "** Question\n%?\n\n** Context\n\n** Potential Answers\n\n** Resources\n\n%(hp/org-roam-insert-context-template)"
           :target
           (file+head "%<%Y%m%d%H%M%S>-question-${slug}.org"
                      "#+title: Question: ${title}\n#+created: %U\n#+filetags: question %(hp/org-roam-get-suggested-tags-for-template)\n#+startup: overview")
           :unnarrowed t))))

(use-package! org-roam-dailies
  :config
  (setq org-roam-dailies-directory "journal/"
        org-roam-dailies-capture-templates
        '(("d" "daily" entry "* %?"
           :target
           (file+head "%<%Y-%m-%d>.org"
                      "#+title: %<%Y-%m-%d %a>\n#+filetags: journal\n#+startup: content\n#+created: %U\n\n")
           :immediate-finish t))))

;; Add web capture template to org-roam-capture-templates
(after! org-roam-capture
  (add-to-list 'org-roam-capture-templates
               '("w" "web" plain "%i\n\n%?"
                 :target
                 (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                            "#+title: ${title}\n#+created: %U\n#+filetags: web\n#+roam_refs: %c\n#+startup: overview\n\n")
                 :unnarrowed t))
  ;; Add web clipping template
  (add-to-list 'org-roam-capture-templates
               '("c" "clipping" plain "%i\n\n** Source\n- URL: %c\n- Date: %U\n\n** Content\n%?"
                 :target
                 (file+head "%<%Y%m%d%H%M%S>-clipping-${slug}.org"
                            "#+title: ${title}\n#+created: %U\n#+filetags: clippings\n#+roam_refs: %c\n#+startup: overview\n\n")
                 :unnarrowed t)))

;; Function to add clipping to index
(defun hp/org-roam-add-to-clippings-index (title file-path url)
  "Add a new clipping entry to the Clippings index."
  (let ((index-file (expand-file-name "Clippings.org" org-roam-directory)))
    (unless (file-exists-p index-file)
      ;; Create the index file if it doesn't exist
      (with-temp-file index-file
        (insert "#+title: Clippings Index\n")
        (insert "#+created: ")
        (insert (format-time-string "[%Y-%m-%d %a %H:%M]"))
        (insert "\n#+filetags: index clippings\n")
        (insert "#+startup: overview\n\n")
        (insert "* Web Clippings\n\n")
        (insert "This is an automatically maintained index of all web clippings.\n\n")))
    
    ;; Add the new clipping entry
    (with-current-buffer (find-file-noselect index-file)
      (goto-char (point-max))
      (insert (format "- [[file:%s][%s]] - %s\n" 
                      (file-relative-name file-path org-roam-directory)
                      title
                      (format-time-string "%Y-%m-%d")))
      (when url
        (insert (format "  - Source: %s\n" url)))
      (save-buffer))))

;; Hook to auto-add clippings to index
(defun hp/org-roam-clipping-finalize-hook ()
  "Hook to run after capturing a web clipping."
  (when (and (bound-and-true-p org-capture-mode)
             (string-match-p "clipping" (or (buffer-file-name) "")))
    (let ((title (org-get-title))
          (file-path (buffer-file-name))
          (url (save-excursion
                 (goto-char (point-min))
                 (when (re-search-forward "#+roam_refs: \\(.*\\)" nil t)
                   (match-string 1)))))
      (when title
        (hp/org-roam-add-to-clippings-index title file-path url)))))

(add-hook 'org-capture-after-finalize-hook #'hp/org-roam-clipping-finalize-hook)

***** Multi-Dimensional Note Navigation

#+begin_src emacs-lisp
;; Multi-dimensional navigation system for org-roam
(defvar hp/org-roam-navigation-dimensions
  '(("temporal" . (("recent" . "recently modified")
                   ("old" . "older content")
                   ("today" . "created today")
                   ("week" . "created this week")))
    ("semantic" . (("related" . "semantically related")
                   ("similar" . "similar content")
                   ("referenced" . "frequently referenced")
                   ("orphaned" . "unlinked nodes")))
    ("structural" . (("hub" . "highly connected nodes")
                     ("leaf" . "terminal nodes")
                     ("bridge" . "bridge nodes")
                     ("cluster" . "clustered nodes")))
    ("functional" . (("concept" . "conceptual notes")
                     ("project" . "project-related")
                     ("literature" . "literature notes")
                     ("journal" . "journal entries"))))
  "Dimensions and filters for multi-dimensional navigation.")

(defvar hp/org-roam-current-navigation-state
  '((dimension . "temporal")
    (filter . "recent")
    (depth . 2)
    (context . nil))
  "Current state of multi-dimensional navigation.")

(defun hp/org-roam-navigate-by-dimension (dimension filter)
  "Navigate nodes by specified dimension and filter."
  (interactive 
   (let* ((dim-choices (mapcar #'car hp/org-roam-navigation-dimensions))
          (selected-dim (completing-read "Dimension: " dim-choices))
          (filter-choices (cdr (assoc selected-dim hp/org-roam-navigation-dimensions)))
          (selected-filter (completing-read "Filter: " (mapcar #'car filter-choices))))
     (list selected-dim selected-filter)))
  
  (setf (alist-get 'dimension hp/org-roam-current-navigation-state) dimension)
  (setf (alist-get 'filter hp/org-roam-current-navigation-state) filter)
  
  (let ((nodes (hp/org-roam-get-nodes-by-dimension dimension filter)))
    (if nodes
        (hp/org-roam-show-navigation-results dimension filter nodes)
      (message "No nodes found for %s:%s" dimension filter))))

(defun hp/org-roam-get-nodes-by-dimension (dimension filter)
  "Get nodes based on dimension and filter criteria."
  (let ((all-nodes (org-roam-node-list)))
    (cond
     ;; Temporal dimension
     ((and (string= dimension "temporal") (string= filter "recent"))
      (seq-take (sort all-nodes (lambda (a b)
                                  (time-less-p (org-roam-node-file-mtime b)
                                              (org-roam-node-file-mtime a)))) 20))
     
     ((and (string= dimension "temporal") (string= filter "today"))
      (let ((today (format-time-string "%Y-%m-%d")))
        (seq-filter (lambda (node)
                      (string-prefix-p today 
                                      (format-time-string "%Y-%m-%d" 
                                                         (org-roam-node-file-mtime node))))
                    all-nodes)))
     
     ((and (string= dimension "temporal") (string= filter "week"))
      (let ((week-ago (time-subtract (current-time) (days-to-time 7))))
        (seq-filter (lambda (node)
                      (time-less-p week-ago (org-roam-node-file-mtime node)))
                    all-nodes)))
     
     ;; Semantic dimension
     ((and (string= dimension "semantic") (string= filter "orphaned"))
      (seq-filter (lambda (node)
                    (= 0 (caar (org-roam-db-query
                               "SELECT COUNT(*) FROM links WHERE target = ?"
                               (org-roam-node-id node)))))
                  all-nodes))
     
     ((and (string= dimension "semantic") (string= filter "referenced"))
      (let ((referenced-nodes '()))
        (dolist (node all-nodes)
          (let ((ref-count (caar (org-roam-db-query
                                 "SELECT COUNT(*) FROM links WHERE target = ?"
                                 (org-roam-node-id node)))))
            (when (> ref-count 2)
              (push (cons ref-count node) referenced-nodes))))
        (mapcar #'cdr (sort referenced-nodes (lambda (a b) (> (car a) (car b)))))))
     
     ;; Structural dimension
     ((and (string= dimension "structural") (string= filter "hub"))
      (let ((hub-nodes '()))
        (dolist (node all-nodes)
          (let ((link-count (+ (caar (org-roam-db-query
                                     "SELECT COUNT(*) FROM links WHERE source = ?"
                                     (org-roam-node-id node)))
                              (caar (org-roam-db-query
                                     "SELECT COUNT(*) FROM links WHERE target = ?"
                                     (org-roam-node-id node))))))
            (when (> link-count 5)
              (push (cons link-count node) hub-nodes))))
        (mapcar #'cdr (sort hub-nodes (lambda (a b) (> (car a) (car b)))))))
     
     ((and (string= dimension "structural") (string= filter "leaf"))
      (seq-filter (lambda (node)
                    (and (= 0 (caar (org-roam-db-query
                                    "SELECT COUNT(*) FROM links WHERE source = ?"
                                    (org-roam-node-id node))))
                         (> 0 (caar (org-roam-db-query
                                    "SELECT COUNT(*) FROM links WHERE target = ?"
                                    (org-roam-node-id node))))))
                  all-nodes))
     
     ;; Functional dimension
     ((and (string= dimension "functional") (string= filter "concept"))
      (seq-filter (lambda (node)
                    (member "concept" (org-roam-node-tags node)))
                  all-nodes))
     
     ((and (string= dimension "functional") (string= filter "project"))
      (seq-filter (lambda (node)
                    (member "project" (org-roam-node-tags node)))
                  all-nodes))
     
     (t all-nodes))))

(defun hp/org-roam-show-navigation-results (dimension filter nodes)
  "Show navigation results in a dedicated buffer."
  (let ((buffer (get-buffer-create "*Org-Roam Navigation*")))
    (with-current-buffer buffer
      (erase-buffer)
      (insert (format "# Multi-Dimensional Navigation: %s → %s\n\n" 
                     (capitalize dimension) filter))
      
      (insert (format "Found %d nodes\n\n" (length nodes)))
      
      (dolist (node nodes)
        (let ((title (org-roam-node-title node))
              (id (org-roam-node-id node))
              (tags (org-roam-node-tags node))
              (mtime (format-time-string "%Y-%m-%d" (org-roam-node-file-mtime node))))
          (insert (format "** [[id:%s][%s]]\n" id title))
          (when tags
            (insert (format "   Tags: %s\n" (string-join tags ", "))))
          (insert (format "   Modified: %s\n\n" mtime))))
      
      (insert "\n## Navigation Options\n")
      (insert "- Press 'n' for next dimension\n")
      (insert "- Press 'f' to change filter\n") 
      (insert "- Press 'r' to refine results\n")
      (insert "- Press 'RET' on a link to visit\n")
      
      (org-mode)
      (goto-char (point-min))
      (hp/org-roam-navigation-mode 1))
    
    (pop-to-buffer buffer)))

(define-minor-mode hp/org-roam-navigation-mode
  "Minor mode for multi-dimensional org-roam navigation."
  :keymap (let ((map (make-sparse-keymap)))
            (define-key map (kbd "n") #'hp/org-roam-navigate-next-dimension)
            (define-key map (kbd "f") #'hp/org-roam-navigate-change-filter)
            (define-key map (kbd "r") #'hp/org-roam-navigate-refine)
            (define-key map (kbd "q") #'quit-window)
            map))

(defun hp/org-roam-navigate-next-dimension ()
  "Navigate to the next dimension."
  (interactive)
  (let* ((current-dim (alist-get 'dimension hp/org-roam-current-navigation-state))
         (dimensions (mapcar #'car hp/org-roam-navigation-dimensions))
         (current-index (seq-position dimensions current-dim))
         (next-index (mod (1+ current-index) (length dimensions)))
         (next-dim (nth next-index dimensions))
         (filters (cdr (assoc next-dim hp/org-roam-navigation-dimensions)))
         (first-filter (caar filters)))
    (hp/org-roam-navigate-by-dimension next-dim first-filter)))

(defun hp/org-roam-navigate-change-filter ()
  "Change filter within current dimension."
  (interactive)
  (let* ((current-dim (alist-get 'dimension hp/org-roam-current-navigation-state))
         (filters (cdr (assoc current-dim hp/org-roam-navigation-dimensions)))
         (selected-filter (completing-read "Filter: " (mapcar #'car filters))))
    (hp/org-roam-navigate-by-dimension current-dim selected-filter)))

(defun hp/org-roam-navigate-refine ()
  "Refine current navigation results."
  (interactive)
  (let ((refinement (completing-read "Refine by: " 
                                    '("tag" "title-contains" "recent-only" "exclude-tag"))))
    (message "Refinement: %s (implementation pending)" refinement)))

(defun hp/org-roam-create-navigation-dashboard ()
  "Create a navigation dashboard showing all dimensions."
  (interactive)
  (let ((buffer (get-buffer-create "*Org-Roam Dashboard*")))
    (with-current-buffer buffer
      (erase-buffer)
      (insert "# Org-Roam Navigation Dashboard\n\n")
      
      (dolist (dim-info hp/org-roam-navigation-dimensions)
        (let ((dimension (car dim-info))
              (filters (cdr dim-info)))
          (insert (format "## %s Dimension\n" (capitalize dimension)))
          (dolist (filter-info filters)
            (let* ((filter (car filter-info))
                   (description (cdr filter-info))
                   (count (length (hp/org-roam-get-nodes-by-dimension dimension filter))))
              (insert (format "- [[elisp:(hp/org-roam-navigate-by-dimension \"%s\" \"%s\")][%s]] (%d nodes) - %s\n"
                             dimension filter filter count description))))
          (insert "\n")))
      
      (insert "## Quick Actions\n")
      (insert "- [[elisp:(hp/org-roam-enhanced-capture)][Enhanced Capture]]\n")
      (insert "- [[elisp:(hp/org-roam-find-similar-nodes)][Find Similar Nodes]]\n")
      (insert "- [[elisp:(hp/org-roam-cluster-analysis)][Cluster Analysis]]\n")
      (insert "- [[elisp:(hp/org-roam-find-stale-links)][Find Stale Links]]\n")
      
      (org-mode)
      (goto-char (point-min)))
    (pop-to-buffer buffer)))

(defun hp/org-roam-spatial-navigation ()
  "Navigate through org-roam using spatial/visual metaphors."
  (interactive)
  (let* ((current-node (org-roam-node-at-point))
         (connected-nodes (when current-node
                           (org-roam-db-query
                            "SELECT target FROM links WHERE source = ?"
                            (org-roam-node-id current-node))))
         (directions '("north" "south" "east" "west" "up" "down")))
    (when current-node
      (let ((buffer (get-buffer-create "*Spatial Navigation*")))
        (with-current-buffer buffer
          (erase-buffer)
          (insert (format "# Spatial Navigation from: %s\n\n" 
                         (org-roam-node-title current-node)))
          (insert "```\n")
          (insert "      [North]\n")
          (insert "        ↑\n")
          (insert "[West] ← YOU → [East]\n")
          (insert "        ↓\n")
          (insert "      [South]\n")
          (insert "```\n\n")
          
          (let ((direction-nodes (seq-take connected-nodes 6)))
            (dotimes (i (length direction-nodes))
              (let* ((direction (nth i directions))
                     (node-id (car (nth i direction-nodes)))
                     (node (org-roam-node-from-id node-id)))
                (when node
                  (insert (format "**%s**: [[id:%s][%s]]\n" 
                                 (capitalize direction) node-id 
                                 (org-roam-node-title node)))))))
          
          (org-mode)
          (goto-char (point-min)))
        (pop-to-buffer buffer)))))
#+end_src

***** Research Thread Visualization System

#+begin_src emacs-lisp
;; Research thread visualization system for org-roam
(defvar hp/org-roam-thread-types
  '(("concept-development" . "🧠")
    ("literature-review" . "📚")
    ("methodology" . "🔬")
    ("analysis" . "📊")
    ("argumentation" . "💭")
    ("citation-chain" . "🔗")
    ("temporal-sequence" . "⏰"))
  "Types of research threads with their visual indicators.")

(defvar hp/org-roam-thread-colors
  '(("concept-development" . "#FF6B6B")
    ("literature-review" . "#4ECDC4")
    ("methodology" . "#45B7D1")
    ("analysis" . "#96CEB4")
    ("argumentation" . "#FFEAA7")
    ("citation-chain" . "#DDA0DD")
    ("temporal-sequence" . "#98D8C8"))
  "Colors for different research thread types.")

(defun hp/org-roam-identify-research-threads ()
  "Identify and categorize research threads in the knowledge base."
  (interactive)
  (let* ((all-nodes (org-roam-node-list))
         (threads (make-hash-table :test 'equal))
         (processed-nodes (make-hash-table :test 'equal)))
    
    (dolist (node all-nodes)
      (unless (gethash (org-roam-node-id node) processed-nodes)
        (let ((thread (hp/org-roam-trace-thread node)))
          (when (> (length thread) 2) ; Only consider threads with 3+ nodes
            (let* ((thread-type (hp/org-roam-classify-thread thread))
                   (thread-key (format "%s-%d" thread-type (hash-table-count threads))))
              (puthash thread-key thread threads)
              ;; Mark nodes as processed
              (dolist (thread-node thread)
                (puthash (org-roam-node-id thread-node) t processed-nodes)))))))
    
    (hp/org-roam-visualize-threads threads)))

(defun hp/org-roam-trace-thread (start-node &optional visited max-depth)
  "Trace a research thread starting from a node."
  (setq visited (or visited (make-hash-table :test 'equal)))
  (setq max-depth (or max-depth 10))
  
  (when (and (> max-depth 0) 
             (not (gethash (org-roam-node-id start-node) visited)))
    (puthash (org-roam-node-id start-node) t visited)
    
    (let* ((connected-ids (org-roam-db-query
                          "SELECT target FROM links WHERE source = ?"
                          (org-roam-node-id start-node)))
           (connected-nodes (mapcar (lambda (id) (org-roam-node-from-id (car id)))
                                   connected-ids))
           (thread (list start-node)))
      
      ;; Follow the strongest connections
      (dolist (node connected-nodes)
        (when (and node (not (gethash (org-roam-node-id node) visited)))
          (let ((connection-strength (hp/org-roam-calculate-connection-strength 
                                     start-node node)))
            (when (> connection-strength 0.5) ; Threshold for strong connections
              (let ((sub-thread (hp/org-roam-trace-thread node visited (1- max-depth))))
                (setq thread (append thread sub-thread)))))))
      
      thread)))

(defun hp/org-roam-calculate-connection-strength (node1 node2)
  "Calculate connection strength between two nodes."
  (let* ((shared-tags (seq-intersection (org-roam-node-tags node1) 
                                       (org-roam-node-tags node2)))
         (tag-score (* 0.3 (length shared-tags)))
         (temporal-score (hp/org-roam-calculate-temporal-proximity node1 node2))
         (citation-score (hp/org-roam-check-citation-relationship node1 node2)))
    (+ tag-score temporal-score citation-score)))

(defun hp/org-roam-calculate-temporal-proximity (node1 node2)
  "Calculate temporal proximity score between two nodes."
  (let* ((time1 (org-roam-node-file-mtime node1))
         (time2 (org-roam-node-file-mtime node2))
         (time-diff (abs (float-time (time-subtract time1 time2))))
         (days-diff (/ time-diff 86400)))
    (cond
     ((< days-diff 1) 0.4)   ; Same day
     ((< days-diff 7) 0.3)   ; Same week
     ((< days-diff 30) 0.2)  ; Same month
     (t 0.1))))              ; Older

(defun hp/org-roam-check-citation-relationship (node1 node2)
  "Check if nodes have citation relationships."
  (let* ((id1 (org-roam-node-id node1))
         (id2 (org-roam-node-id node2))
         (direct-link (org-roam-db-query
                      "SELECT COUNT(*) FROM links WHERE source = ? AND target = ?"
                      id1 id2))
         (reverse-link (org-roam-db-query
                       "SELECT COUNT(*) FROM links WHERE source = ? AND target = ?"
                       id2 id1)))
    (cond
     ((or (> (caar direct-link) 0) (> (caar reverse-link) 0)) 0.5)
     (t 0))))

(defun hp/org-roam-classify-thread (thread)
  "Classify a research thread based on its characteristics."
  (let* ((tags (flatten-list (mapcar #'org-roam-node-tags thread)))
         (tag-frequencies (make-hash-table :test 'equal)))
    
    ;; Count tag frequencies
    (dolist (tag tags)
      (puthash tag (1+ (gethash tag tag-frequencies 0)) tag-frequencies))
    
    ;; Classify based on dominant tags and patterns
    (cond
     ((or (gethash "literature" tag-frequencies)
          (gethash "paper" tag-frequencies)
          (gethash "review" tag-frequencies))
      "literature-review")
     ((or (gethash "concept" tag-frequencies)
          (gethash "theory" tag-frequencies)
          (gethash "definition" tag-frequencies))
      "concept-development")
     ((or (gethash "method" tag-frequencies)
          (gethash "methodology" tag-frequencies)
          (gethash "experiment" tag-frequencies))
      "methodology")
     ((or (gethash "analysis" tag-frequencies)
          (gethash "data" tag-frequencies)
          (gethash "results" tag-frequencies))
      "analysis")
     ((hp/org-roam-has-temporal-sequence thread)
      "temporal-sequence")
     (t "concept-development"))))

(defun hp/org-roam-has-temporal-sequence (thread)
  "Check if thread represents a clear temporal sequence."
  (when (> (length thread) 2)
    (let ((times (mapcar #'org-roam-node-file-mtime thread)))
      (equal times (sort (copy-sequence times) #'time-less-p)))))

(defun hp/org-roam-visualize-threads (threads)
  "Visualize research threads in a dedicated buffer."
  (let ((buffer (get-buffer-create "*Research Threads*")))
    (with-current-buffer buffer
      (erase-buffer)
      (insert "# Research Thread Visualization\n\n")
      
      (maphash (lambda (thread-key thread)
                 (let* ((thread-type (car (split-string thread-key "-")))
                        (thread-icon (cdr (assoc thread-type hp/org-roam-thread-types)))
                        (thread-color (cdr (assoc thread-type hp/org-roam-thread-colors))))
                   
                   (insert (format "## %s %s Thread (%d nodes)\n\n" 
                                  (or thread-icon "🔗") 
                                  (capitalize (replace-regexp-in-string "-" " " thread-type))
                                  (length thread)))
                   
                   ;; Create visual thread representation
                   (dotimes (i (length thread))
                     (let* ((node (nth i thread))
                            (title (org-roam-node-title node))
                            (id (org-roam-node-id node))
                            (connector (if (< i (1- (length thread))) " → " "")))
                       (insert (format "[[id:%s][%s]]%s" id title connector))))
                   
                   (insert "\n\n")
                   
                   ;; Add thread analysis
                   (insert "### Thread Analysis\n")
                   (let* ((start-time (org-roam-node-file-mtime (car thread)))
                          (end-time (org-roam-node-file-mtime (car (last thread))))
                          (duration (/ (float-time (time-subtract end-time start-time)) 86400))
                          (all-tags (delete-dups (flatten-list (mapcar #'org-roam-node-tags thread)))))
                     (insert (format "- **Duration**: %.1f days\n" duration))
                     (insert (format "- **Key Tags**: %s\n" (string-join all-tags ", ")))
                     (insert (format "- **Thread Strength**: %.2f\n" 
                                    (hp/org-roam-calculate-thread-strength thread))))
                   
                   (insert "\n---\n\n")))
               threads)
      
      (insert "## Thread Statistics\n")
      (insert (format "- Total threads identified: %d\n" (hash-table-count threads)))
      
      (let ((type-counts (make-hash-table :test 'equal)))
        (maphash (lambda (key _)
                   (let ((type (car (split-string key "-"))))
                     (puthash type (1+ (gethash type type-counts 0)) type-counts)))
                 threads)
        (insert "\n### Thread Types\n")
        (maphash (lambda (type count)
                   (let ((icon (cdr (assoc type hp/org-roam-thread-types))))
                     (insert (format "- %s %s: %d threads\n" 
                                    (or icon "🔗") 
                                    (capitalize (replace-regexp-in-string "-" " " type)) 
                                    count))))
                 type-counts))
      
      (org-mode)
      (goto-char (point-min)))
    (pop-to-buffer buffer)))

(defun hp/org-roam-calculate-thread-strength (thread)
  "Calculate the overall strength of a research thread."
  (if (< (length thread) 2)
      0.0
    (let ((total-strength 0.0)
          (connections 0))
      (dotimes (i (1- (length thread)))
        (let ((strength (hp/org-roam-calculate-connection-strength 
                        (nth i thread) (nth (1+ i) thread))))
          (setq total-strength (+ total-strength strength))
          (setq connections (1+ connections))))
      (if (> connections 0)
          (/ total-strength connections)
        0.0))))

(defun hp/org-roam-export-thread-graph (thread-key)
  "Export a research thread as a visual graph."
  (interactive 
   (list (completing-read "Thread to export: " 
                         (hash-table-keys hp/org-roam-current-threads))))
  (let* ((thread (gethash thread-key hp/org-roam-current-threads))
         (graph-file (expand-file-name 
                     (format "thread-%s.dot" thread-key) 
                     temporary-file-directory)))
    (with-temp-file graph-file
      (insert "digraph ResearchThread {\n")
      (insert "  rankdir=LR;\n")
      (insert "  node [shape=box, style=filled];\n")
      
      (dotimes (i (length thread))
        (let* ((node (nth i thread))
               (title (org-roam-node-title node))
               (clean-title (replace-regexp-in-string "[^a-zA-Z0-9]" "_" title)))
          (insert (format "  %s [label=\"%s\"];\n" clean-title title))
          (when (< i (1- (length thread)))
            (let* ((next-node (nth (1+ i) thread))
                   (next-title (org-roam-node-title next-node))
                   (next-clean (replace-regexp-in-string "[^a-zA-Z0-9]" "_" next-title)))
              (insert (format "  %s -> %s;\n" clean-title next-clean))))))
      
      (insert "}\n"))
    
    (message "Thread graph exported to: %s" graph-file)
    (when (executable-find "dot")
      (let ((png-file (replace-regexp-in-string "\\.dot$" ".png" graph-file)))
        (shell-command (format "dot -Tpng %s -o %s" graph-file png-file))
        (message "PNG graph created: %s" png-file)))))

(defvar hp/org-roam-current-threads (make-hash-table :test 'equal)
  "Currently identified research threads.")

;; Store threads globally for export functionality
(advice-add 'hp/org-roam-visualize-threads :before
            (lambda (threads)
              (setq hp/org-roam-current-threads threads)))
#+end_src

***** Org-download configuration
#+begin_src emacs-lisp
(use-package! org-download
  :after org
  :config
  (setq org-download-method 'directory
        org-download-image-dir "attachments"
        org-download-heading-lvl nil
        org-download-timestamp "%Y%m%d-%H%M%S_"
        org-download-screenshot-method "screencapture -i %s"
        org-download-screenshot-file (expand-file-name "screenshot.png" temporary-file-directory))
  
  ;; Automatically download images when pasting URLs
  (setq org-download-image-html-width 600)
  
  ;; Enable drag-and-drop for images
  (org-download-enable))
#+end_src

  (map! :leader
        :prefix "n"
        (:prefix ("j" . "journal")
         :desc "Arbitrary date" "d" #'org-roam-dailies-goto-date
         :desc "Today"          "j" #'org-roam-dailies-goto-today
         :desc "Tomorrow"       "m" #'org-roam-dailies-goto-tomorrow
         :desc "Yesterday"      "y" #'org-roam-dailies-goto-yesterday)))
;; Obsidian
(map! :leader
        :prefix "n"
        (:prefix ("O" . "obsidian")
         ;; Obsidian functions
         :desc "Obsidian jump to note" "j" #'obsidian-jump
         :desc "Obsidian capture note" "c" #'obsidian-capture
         :desc "Obsidian insert wikilink" "l" #'obsidian-insert-wikilink
         :desc "Obsidian insert link" "L" #'obsidian-insert-link
         :desc "Obsidian follow link" "f" #'obsidian-follow-link-at-point
         :desc "Obsidian update metadata" "u" #'obsidian-update
         :desc "Obsidian tag find" "t" #'obsidian-tag-find
         :desc "Obsidian change vault" "v" #'obsidian-change-vault
         :desc "Obsidian specify path" "p" #'obsidian-specify-path
         :desc "Open vault with treemacs" "V" #'hp/obsidian-open-vault-with-treemacs))

;; Org-roam tools keybindings
(map! :leader
        :prefix "n"
        (:prefix ("r" . "roam")
         (:prefix ("t" . "tools")
          ;; File management tools
          :desc "Rename roam files" "r" #'hp/org-roam-rename-files
          :desc "Flatten roam files" "f" #'hp/org-roam-flatten-files
          
          ;; Semantic links
          (:prefix ("s" . "semantic links")
           :desc "Insert semantic link" "l" #'hp/org-roam-insert-semantic-link
           :desc "Show relationship graph" "g" #'hp/org-roam-show-relationship-graph
           :desc "Find by relationship" "f" #'hp/org-roam-find-by-relationship
           :desc "Relationship stats" "s" #'hp/org-roam-get-relationship-stats)
          
          ;; Clustering & tagging
          (:prefix ("c" . "clustering")
           :desc "Auto-tag current node" "t" #'hp/org-roam-auto-tag-current-node
           :desc "Find similar nodes" "s" #'hp/org-roam-find-similar-nodes
           :desc "Cluster analysis" "c" #'hp/org-roam-cluster-analysis
           :desc "Update tag weights" "w" #'hp/org-roam-update-tag-weights)
          
          ;; Time-based decay & refresh
          (:prefix ("d" . "decay & refresh")
           :desc "Find stale links" "s" #'hp/org-roam-find-stale-links
           :desc "Refresh node timestamp" "r" #'hp/org-roam-refresh-node-timestamp
           :desc "Weighted node search" "w" #'hp/org-roam-weighted-node-search
           :desc "Colorize links by age" "c" #'hp/org-roam-colorize-links-by-age
           :desc "Cleanup stale content" "x" #'hp/org-roam-cleanup-stale-content)
          
          ;; Enhanced capture
          (:prefix ("e" . "enhanced capture")
           :desc "Context-aware capture" "c" #'hp/org-roam-enhanced-capture
           :desc "Show current context" "s" (lambda () (interactive) 
                                               (hp/org-roam-show-capture-context 
                                                (hp/org-roam-get-current-context) '() '())))
          
          ;; Multi-dimensional navigation
          (:prefix ("n" . "navigation")
           :desc "Navigate by dimension" "d" #'hp/org-roam-navigate-by-dimension
           :desc "Navigation dashboard" "D" #'hp/org-roam-create-navigation-dashboard
           :desc "Spatial navigation" "s" #'hp/org-roam-spatial-navigation)
          
          ;; Research thread visualization
          (:prefix ("v" . "visualization")
           :desc "Identify research threads" "t" #'hp/org-roam-identify-research-threads
           :desc "Export thread graph" "e" #'hp/org-roam-export-thread-graph)))
         
         :desc "Capture web page" "w" (lambda () (interactive) (org-roam-capture- :keys "w"))
         :desc "Capture web clipping" "c" (lambda () (interactive) (org-roam-capture- :keys "c"))))

;; Custom function to open Obsidian vault with treemacs
(defun hp/obsidian-open-vault-with-treemacs ()
  "Open the Obsidian vault directory, split window, and launch treemacs."
  (interactive)
  ;; Open the vault directory in dired
  (find-file obsidian-directory)
  ;; Split window vertically
  (split-window-right)
  ;; Open treemacs
  (treemacs)
  ;; Navigate treemacs to the vault directory
  (treemacs-find-file obsidian-directory))

;; Obsidian package configuration
(use-package! obsidian
  :ensure t
  :defer t
  :commands (obsidian-jump
             obsidian-capture
             obsidian-insert-wikilink
             obsidian-insert-link
             obsidian-follow-link-at-point
             obsidian-update
             obsidian-tag-find
             obsidian-change-vault
             obsidian-specify-path
             hp/obsidian-open-vault-with-treemacs)
  :config
  (setq obsidian-directory "~/Documents/Obsidian/Obsidian/")
  (global-obsidian-mode))
#+end_src

**** Obsidian to Org-mode Conversion
These functions handle converting Obsidian markdown files to org-mode format, preserving
wikilinks, attachments, and metadata.

#+begin_src emacs-lisp
;; Core conversion functions for Obsidian to Org-mode
(defvar hp/obsidian-org-output-dir (concat org-roam-directory "obsidian-import/")
  "Directory where converted Obsidian files will be stored.")

(defvar hp/obsidian-attachment-dirs '("attachments" "Attachments" "assets" "Assets")
  "List of common attachment directory names in Obsidian vaults.")

(defun hp/obsidian-to-org--extract-data (content)
  "Extract minimal data from Obsidian CONTENT.
Returns a plist with :title :tags :created :body."
  (let ((data '()))
    (if (string-match "^---\n\\(\\(?:.*\n\\)*?\\)---\n" content)
        (let* ((frontmatter (match-string 1 content))
               (body (substring content (match-end 0))))
          ;; Extract body content - use setq to ensure we update the outer data
          (setq data (plist-put data :body body))
          ;; Parse only essential frontmatter fields
          (with-temp-buffer
            (insert frontmatter)
            (goto-char (point-min))
            (while (re-search-forward "^\\([^:]+\\):\\s-*\\(.+\\)$" nil t)
              (let* ((key (downcase (match-string 1)))
                     (value (match-string 2)))
                ;; Clean up values
                (setq value (replace-regexp-in-string "^[\"']\\|[\"']$" "" value))
                (cond
                 ;; Extract title
                 ((string= key "title")
                  (setq data (plist-put data :title value)))
                 ;; Extract tags - handle both arrays and strings
                 ((string= key "tags")
                  (cond
                   ;; YAML array format: [tag1, tag2]
                   ((string-match "\\[\\(.+\\)\\]" value)
                    (let ((tags-str (match-string 1 value)))
                      (setq tags-str (replace-regexp-in-string "\\s-*,\\s-*" " " tags-str))
                      (setq tags-str (replace-regexp-in-string "^\\s-*-\\s-*" "" tags-str))
                      (setq data (plist-put data :tags (split-string tags-str)))))
                   ;; YAML list format with dashes
                   ((string-match "^\\s*-\\s*" value)
                    (setq data (plist-put data :tags (list (replace-regexp-in-string "^\\s*-\\s*" "" value)))))
                   ;; Simple string
                   (t (setq data (plist-put data :tags (split-string value))))))
                 ;; Extract created date
                 ((member key '("created" "date"))
                  (setq data (plist-put data :created value))))))))
      ;; No frontmatter, just use the content as body
      (setq data (plist-put data :body content)))
    data))

(defun hp/obsidian-to-org--rebuild-org-file (data filename)
  "Rebuild a clean org file from extracted DATA.
DATA should be a plist with :title :tags :created :body.
FILENAME is used as fallback for title."
  (let* ((title (or (plist-get data :title) 
                    (file-name-sans-extension filename)))
         (tags (plist-get data :tags))
         (created (plist-get data :created))
         (body (or (plist-get data :body) ""))
         (org-content ""))
    
    ;; Build minimal properties drawer with just ID
    (setq org-content ":PROPERTIES:\n")
    (setq org-content (concat org-content (format ":ID:       %s\n" (org-id-new))))
    (setq org-content (concat org-content ":END:\n"))
    
    ;; Add title with inline tags if present
    (if (and tags (listp tags) (> (length tags) 0))
        (let* ((valid-tags (seq-filter (lambda (tag) (and tag (stringp tag))) tags))
               (tag-string (when valid-tags
                            (mapconcat (lambda (tag) 
                                        (concat ":" (replace-regexp-in-string "\\s-+" "" tag) ":"))
                                      valid-tags " "))))
          (if (and tag-string (not (string-empty-p tag-string)))
              (setq org-content (concat org-content (format "#+title: %s %s\n" title tag-string)))
            (setq org-content (concat org-content (format "#+title: %s\n" title)))))
      (setq org-content (concat org-content (format "#+title: %s\n" title))))
    
    ;; Add created date if present
    (when (and created (stringp created))
      (let ((date-str (if (string-match "\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\)" created)
                         (match-string 1 created)
                       created)))
        (setq org-content (concat org-content (format "#+created: [%s]\n" date-str)))))
    
    ;; Add filetags if present
    (when (and tags (listp tags) (> (length tags) 0))
      (let* ((valid-tags (seq-filter (lambda (tag) (and tag (stringp tag))) tags))
             (filetags (when valid-tags
                        (string-join (mapcar (lambda (tag) 
                                              (replace-regexp-in-string "\\s-+" "" tag))
                                            valid-tags) " "))))
        (when (and filetags (not (string-empty-p filetags)))
          (setq org-content (concat org-content (format "#+filetags: %s\n" filetags))))))
    
    ;; Add startup directive
    (setq org-content (concat org-content "#+startup: overview\n\n"))
    
    ;; Add body content
    (setq org-content (concat org-content body))
    
    org-content))

(defun hp/obsidian-to-org--convert-wikilinks (content)
  "Convert Obsidian wikilinks in CONTENT to org links."
  (let ((link-map '()))
    ;; First pass: collect all wikilinks and create ID mappings
    (with-temp-buffer
      (insert content)
      (goto-char (point-min))
      (while (re-search-forward "\\[\\[\\([^]|]+\\)\\(?:|\\([^]]+\\)\\)?\\]\\]" nil t)
        (let* ((link (match-string 1))
               (desc (or (match-string 2) link))
               (id (org-id-new)))
          (push (list link desc id) link-map))))

    ;; Second pass: replace wikilinks with org-roam links
    (dolist (link-info link-map)
      (let ((link (nth 0 link-info))
            (desc (nth 1 link-info))
            (id (nth 2 link-info)))
        (setq content (replace-regexp-in-string
                      (regexp-quote (format "[[%s]]" link))
                      (format "[[id:%s][%s]]" id desc)
                      content))
        (setq content (replace-regexp-in-string
                      (regexp-quote (format "[[%s|%s]]" link desc))
                      (format "[[id:%s][%s]]" id desc)
                      content))))
    content))

(defun hp/obsidian-to-org--convert-image-embeds (content base-dir output-dir)
  "Convert Obsidian image embeds in CONTENT to org syntax.
BASE-DIR is the source directory, OUTPUT-DIR is the destination."
  (let ((attachments-copied '()))
    (with-temp-buffer
      (insert content)
      (goto-char (point-min))

      ;; Convert ![[image]] syntax
      (while (re-search-forward "!\\[\\[\\([^]]+\\)\\]\\]" nil t)
        (let* ((image-ref (match-string 1))
               (image-name (file-name-nondirectory image-ref))
               (new-path ""))

          ;; Find the actual image file
          (catch 'found
            (dolist (attach-dir hp/obsidian-attachment-dirs)
              (let ((possible-path (expand-file-name image-ref
                                                   (expand-file-name attach-dir base-dir))))
                (when (file-exists-p possible-path)
                  ;; Copy attachment if not already copied
                  (unless (member possible-path attachments-copied)
                    (let ((dest-dir (expand-file-name "assets" output-dir)))
                      (make-directory dest-dir t)
                      (copy-file possible-path
                               (expand-file-name image-name dest-dir)
                               t)
                      (push possible-path attachments-copied)))
                  (setq new-path (format "[[file:./assets/%s]]" image-name))
                  (throw 'found t)))))

          ;; Replace the image reference
          (when new-path
            (replace-match new-path t t))))

      ;; Convert ![](url) syntax
      (goto-char (point-min))
      (while (re-search-forward "!\\[\\([^]]*\\)\\](\\([^)]+\\))" nil t)
        (let ((alt-text (match-string 1))
              (url (match-string 2)))
          (replace-match (format "[[%s][%s]]" url (or alt-text url)) t t)))

      (buffer-string))))

(defun hp/obsidian-to-org--convert-tags (content)
  "Convert Obsidian #tags in CONTENT to org format."
  ;; Convert standalone tags
  (setq content (replace-regexp-in-string
                "\\(?:^\\|\\s-\\)#\\([a-zA-Z0-9_-]+\\)"
                " :\\1:"
                content))
  content)

(defun hp/obsidian-to-org--process-body-content (body base-dir output-dir)
  "Process BODY content converting markdown syntax to org.
BASE-DIR is the source directory, OUTPUT-DIR is the destination."
  (if (not (stringp body))
      ""  ; Return empty string if body is not a string
    (let ((result body))
      (condition-case err
          (progn
            ;; Convert wikilinks
            (setq result (hp/obsidian-to-org--convert-wikilinks result))
            
            ;; Convert image embeds
            (setq result (hp/obsidian-to-org--convert-image-embeds result base-dir output-dir))
            
            ;; Convert markdown headers to org headers: # Header → * Header
            (setq result (replace-regexp-in-string "^\\(#+\\)\\s-*\\([^+:].+\\)$" 
                                                  (lambda (match)
                                                    (let ((hashes (match-string 1 match))
                                                          (content (match-string 2 match)))
                                                      (concat (make-string (length hashes) ?*) " " content)))
                                                  result))
            
            ;; Convert text formatting
            (setq result (replace-regexp-in-string "\\*\\*\\([^*\n]+\\)\\*\\*" "*\\1*" result))
            (setq result (replace-regexp-in-string "__\\([^_\n]+\\)__" "*\\1*" result))
            (setq result (replace-regexp-in-string "\\b_\\([^_\n]+\\)_\\b" "/\\1/" result))
            (setq result (replace-regexp-in-string "~~\\([^~\n]+\\)~~" "+\\1+" result))
            (setq result (replace-regexp-in-string "==\\([^=\n]+\\)==" "@@html:<mark>@@\\1@@html:</mark>@@" result))
            
            ;; Convert code blocks
            (setq result (replace-regexp-in-string "```\\([a-zA-Z0-9-_+]*\\)\\s-*\n" "#+begin_src \\1\n" result))
            (setq result (replace-regexp-in-string "^```\\s-*$" "#+end_src" result))
            
            ;; Convert inline code
            (setq result (replace-regexp-in-string "`\\([^`\n]+\\)`" "~\\1~" result))
            
            ;; Convert block quotes
            (setq result (replace-regexp-in-string "^> \\(.+\\)$" "#+begin_quote\n\\1\n#+end_quote" result))
            
            ;; Convert single asterisk italic  
            (setq result (replace-regexp-in-string "\\*\\([^*\n]+?\\)\\*" "/\\1/" result))
            
            ;; Convert markdown links
            (setq result (replace-regexp-in-string "\\[\\([^]]+\\)\\](\\([^)]+\\))" "[[\\2][\\1]]" result))
            
            result)
        (error
         (message "Error processing body content: %s" (error-message-string err))
         body)))))

(defun hp/obsidian-to-org-convert-file (file)
  "Convert a single Obsidian FILE to org-mode format."
  (interactive "fSelect Obsidian file to convert: ")
  (let* ((base-dir (file-name-directory file))
         (file-name (file-name-nondirectory file))
         (org-file-name (concat (file-name-sans-extension file-name) ".org"))
         (output-dir hp/obsidian-org-output-dir)
         (output-file (expand-file-name org-file-name output-dir)))
    
    ;; Read file content
    (with-temp-buffer
      (insert-file-contents file)
      (let* ((content (buffer-string))
             ;; Extract data from Obsidian file
             (data (hp/obsidian-to-org--extract-data content))
             (body (plist-get data :body))
             ;; Process body content for markdown->org conversions
             (processed-body (hp/obsidian-to-org--process-body-content 
                             body base-dir output-dir))
             ;; Update data with processed body
             (updated-data (plist-put (copy-sequence data) :body processed-body))
             ;; Rebuild clean org file
             (org-content (hp/obsidian-to-org--rebuild-org-file updated-data file-name)))
        
        ;; Debug logging
        (message "Debug: Original body length: %s" (if body (length body) "nil"))
        (message "Debug: Processed body length: %s" (if processed-body (length processed-body) "nil"))
        (message "Debug: Final org content length: %s" (length org-content))
        
        ;; Create output directory if needed
        (make-directory output-dir t)
        
        ;; Write to new file
        (with-temp-file output-file
          (insert org-content))
        
        ;; Open the converted file
        (find-file output-file)
        (org-mode)
        ;; Force a single database update
        (org-roam-db-update-file)
        
        (message "Converted %s to %s" file-name output-file)))))

(defun hp/obsidian-to-org-convert-buffer ()
  "Convert current Obsidian markdown buffer to org-mode format."
  (interactive)
  (unless (derived-mode-p 'markdown-mode)
    (user-error "Current buffer is not in markdown mode"))

  (let* ((input-file (buffer-file-name))
         (base-dir (file-name-directory input-file))
         (file-name (file-name-nondirectory input-file))
         (org-file-name (concat (file-name-sans-extension file-name) ".org"))
         (output-dir hp/obsidian-org-output-dir)
         (output-file (expand-file-name org-file-name output-dir))
         (content (buffer-string)))

    ;; Create output directory if needed
    (make-directory output-dir t)

    ;; Extract data from Obsidian file
    (let* ((data (hp/obsidian-to-org--extract-data content))
           (body (plist-get data :body))
           ;; Process body content for markdown->org conversions
           (processed-body (hp/obsidian-to-org--process-body-content 
                           body base-dir output-dir))
           ;; Update data with processed body
           (updated-data (plist-put (copy-sequence data) :body processed-body))
           ;; Rebuild clean org file
           (org-content (hp/obsidian-to-org--rebuild-org-file updated-data file-name)))
      
      ;; Write to new file
      (with-temp-file output-file
        (insert org-content))

      ;; Open the converted file
      (find-file output-file)
      (org-mode)
      ;; Force a single database update
      (org-roam-db-update-file)

      (message "Converted %s to %s" file-name output-file))))

(defun hp/obsidian-to-org-convert-directory (directory &optional recursive)
  "Convert all Obsidian markdown files in DIRECTORY to org-mode.
If RECURSIVE is non-nil, process subdirectories as well."
  (interactive "DDirectory: \nP")

  (let* ((md-files (if recursive
                      (directory-files-recursively directory "\\.md$")
                    (directory-files directory t "\\.md$")))
         (total (length md-files))
         (count 0)
         (errors '()))

    (dolist (file md-files)
      (setq count (1+ count))
      (message "Converting %d/%d: %s" count total (file-name-nondirectory file))

      (condition-case err
          (with-temp-buffer
            (insert-file-contents file)
            (let* ((base-dir (file-name-directory file))
                   (rel-path (file-relative-name file directory))
                   (rel-dir (file-name-directory rel-path))
                   (output-dir (if rel-dir
                                 (expand-file-name rel-dir hp/obsidian-org-output-dir)
                               hp/obsidian-org-output-dir))
                   (org-file-name (concat (file-name-sans-extension
                                         (file-name-nondirectory file)) ".org"))
                   (output-file (expand-file-name org-file-name output-dir))
                   (content (buffer-string)))

              ;; Create output directory structure
              (make-directory output-dir t)

              ;; Extract data and rebuild org file
              (let* ((data (hp/obsidian-to-org--extract-data content))
                     (body (plist-get data :body))
                     ;; Process body content for markdown->org conversions
                     (processed-body (hp/obsidian-to-org--process-body-content 
                                     body base-dir output-dir))
                     ;; Update data with processed body
                     (updated-data (plist-put (copy-sequence data) :body processed-body))
                     ;; Rebuild clean org file
                     (org-content (hp/obsidian-to-org--rebuild-org-file 
                                  updated-data (file-name-nondirectory file))))
                (with-temp-file output-file
                  (insert org-content)))))
        (error
         (push (cons file err) errors))))

    ;; Update org-roam database for all new files
    (org-roam-db-sync)

    ;; Report results
    (if errors
        (message "Converted %d files with %d errors. Check *Messages* for details."
                 (- total (length errors)) (length errors))
      (message "Successfully converted %d files." total))

    ;; Log errors
    (dolist (error errors)
      (message "Error converting %s: %s" (car error) (cdr error)))))

(defun hp/obsidian-to-org-convert-directory-recursive (directory)
  "Convert all Obsidian markdown files in DIRECTORY and all subdirectories to org-mode."
  (interactive "DDirectory: ")
  ;; Just call the regular function with recursive flag set to t
  (hp/obsidian-to-org-convert-directory directory t))

(defun hp/obsidian-to-org-generate-indices (directory)
  "Generate index.org files recursively and move single files up to parent directories."
  (interactive "DDirectory: ")
  (let ((moved-files 0)
        (created-indices 0))
    
    ;; First pass: Move single files up to parent directory
    (hp/obsidian-to-org--consolidate-single-files directory)
    
    ;; Second pass: Create index files for all directories with content
    (hp/obsidian-to-org--create-indices-recursive directory)
    
    ;; Update org-roam database
    (org-roam-db-sync)
    
    (message "Reorganized directory structure and created index files")))

(defun hp/obsidian-to-org--consolidate-single-files (directory)
  "Move files from directories containing only one file up to parent directory."
  (let ((all-dirs (seq-filter #'file-directory-p 
                             (directory-files-recursively directory "." t))))
    ;; Process from deepest to shallowest
    (dolist (dir (sort all-dirs (lambda (a b) (> (length a) (length b)))))
      (let* ((files (directory-files dir t "^[^.].*\\.org$"))
             (non-index-files (seq-remove (lambda (f) 
                                           (string= (file-name-nondirectory f) "index.org"))
                                         files)))
        (when (= (length non-index-files) 1)
          ;; Move the single file to parent directory
          (let* ((file (car non-index-files))
                 (parent-dir (file-name-directory (directory-file-name dir)))
                 (new-path (expand-file-name (file-name-nondirectory file) parent-dir)))
            (unless (file-exists-p new-path)
              (rename-file file new-path)
              (message "Moved %s to %s" (file-name-nondirectory file) parent-dir))
            ;; Remove empty directory
            (when (= (length (directory-files dir t "^[^.]")) 0)
              (delete-directory dir))))))))

(defun hp/obsidian-to-org--create-indices-recursive (directory &optional parent-level)
  "Create index.org files recursively for DIRECTORY and all subdirectories."
  (let ((level (or parent-level 0)))
    ;; Get all files and subdirectories in current directory
    (let* ((all-files (directory-files directory t "^[^.]"))
           (org-files (seq-filter (lambda (f) 
                                   (and (string-match-p "\\.org$" f)
                                        (not (string= (file-name-nondirectory f) "index.org"))))
                                 all-files))
           (subdirs (seq-filter #'file-directory-p all-files)))
      
      ;; Only create index if there are org files or subdirectories
      (when (or org-files subdirs)
        (let ((index-file (expand-file-name "index.org" directory))
              (dir-name (file-name-nondirectory (directory-file-name directory))))
          
          (with-temp-file index-file
            ;; Add org-roam properties
            (insert ":PROPERTIES:\n")
            (insert (format ":ID:       %s\n" (org-id-new)))
            (insert ":END:\n")
            (insert (format "#+title: %s\n\n" (capitalize (replace-regexp-in-string "-" " " dir-name))))
            
            ;; Add ID links to files in current directory
            (dolist (file (sort org-files #'string<))
              (let ((id nil)
                    (title (file-name-sans-extension (file-name-nondirectory file))))
                ;; Extract ID and title from the file
                (when (file-exists-p file)
                  (with-temp-buffer
                    (insert-file-contents file nil 0 1000) ; Read more to ensure we get the ID
                    ;; Extract ID
                    (goto-char (point-min))
                    (when (re-search-forward "^:ID:\\s-+\\([a-zA-Z0-9-]+\\)" nil t)
                      (setq id (match-string 1)))
                    ;; Extract title
                    (goto-char (point-min))
                    (when (re-search-forward "^#\\+title:\\s-*\\(.+\\)$" nil t)
                      (setq title (match-string 1)))))
                ;; Write the ID link
                (when id
                  (insert (format "[[id:%s][%s]]\n" id title)))))
            
            ;; Add links to subdirectory indices
            (when subdirs
              (insert "\n")
              (dolist (subdir (sort subdirs #'string<))
                (let ((subdir-index (expand-file-name "index.org" subdir))
                      (subdir-name (file-name-nondirectory (directory-file-name subdir))))
                  ;; Check if subdirectory will have an index
                  (when (or (directory-files subdir nil "\\.org$")
                           (seq-filter #'file-directory-p 
                                      (directory-files subdir t "^[^.]")))
                    ;; Extract ID from the subdirectory index if it exists
                    (let ((subdir-id nil)
                          (subdir-title (capitalize (replace-regexp-in-string "-" " " subdir-name))))
                      (when (file-exists-p subdir-index)
                        (with-temp-buffer
                          (insert-file-contents subdir-index nil 0 500)
                          (when (re-search-forward "^:ID:\\s-+\\([a-zA-Z0-9-]+\\)" nil t)
                            (setq subdir-id (match-string 1)))))
                      ;; If no ID yet, we'll need to process subdirs first
                      (unless subdir-id
                        ;; Process subdir first to create its index
                        (hp/obsidian-to-org--create-indices-recursive subdir (1+ level))
                        ;; Now try to get the ID again
                        (when (file-exists-p subdir-index)
                          (with-temp-buffer
                            (insert-file-contents subdir-index nil 0 500)
                            (when (re-search-forward "^:ID:\\s-+\\([a-zA-Z0-9-]+\\)" nil t)
                              (setq subdir-id (match-string 1))))))
                      (when subdir-id
                        (insert (format "[[id:%s][%s]]\n" subdir-id subdir-title)))))))))
          
          (message "Created index for %s (level %d)" dir-name level)))
      
      ;; Process remaining subdirectories
      (dolist (subdir subdirs)
        (unless (file-exists-p (expand-file-name "index.org" subdir))
          (hp/obsidian-to-org--create-indices-recursive subdir (1+ level)))))))

(defun hp/obsidian-to-org-convert-and-index (directory)
  "Convert all Obsidian files in DIRECTORY recursively and generate index.org files."
  (interactive "DDirectory: ")
  ;; First convert all markdown files
  (hp/obsidian-to-org-convert-directory-recursive directory)
  ;; Then generate indices
  (hp/obsidian-to-org-generate-indices hp/obsidian-org-output-dir))

(defun hp/org-rename-to-zettelkasten (directory)
  "Rename all org files in DIRECTORY to Zettelkasten format YYYYMMDDHHMMSS-title.org."
  (interactive "DDirectory: ")
  (let ((renamed-count 0)
        (skipped-count 0)
        (error-count 0))
    ;; Get all org files recursively
    (dolist (file (directory-files-recursively directory "\\.org$"))
      (let ((filename (file-name-nondirectory file)))
        ;; Check if file already follows Zettelkasten format
        (unless (or (string-match "^[0-9]\\{14\\}-.*\\.org$" filename)
                    (string= filename "index.org"))
          (condition-case err
              (let ((title nil)
                    (created-date nil))
                ;; Extract title and created date from file
                (with-temp-buffer
                  (insert-file-contents file nil 0 1000)
                  ;; Extract title
                  (goto-char (point-min))
                  (when (re-search-forward "^#\\+title:\\s-*\\(.+\\)$" nil t)
                    (setq title (match-string 1)))
                  ;; Extract created date if available
                  (goto-char (point-min))
                  (when (re-search-forward "^#\\+created:\\s-*\\[\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\)" nil t)
                    (setq created-date (match-string 1))))
                
                (if title
                    (let* (;; Generate timestamp
                           (timestamp (if created-date
                                         ;; Use created date if available
                                         (format-time-string "%Y%m%d%H%M%S" 
                                                           (date-to-time (concat created-date " 00:00:00")))
                                       ;; Otherwise use file modification time
                                       (format-time-string "%Y%m%d%H%M%S" 
                                                         (nth 5 (file-attributes file)))))
                           ;; Clean title for filename
                           (clean-title (hp/org-sanitize-title-for-filename title))
                           ;; Create new filename
                           (new-filename (format "%s-%s.org" timestamp clean-title))
                           (new-filepath (expand-file-name new-filename 
                                                          (file-name-directory file))))
                      
                      ;; Check if new filename already exists
                      (if (file-exists-p new-filepath)
                          (progn
                            (message "Skipped %s: Target file already exists" filename)
                            (setq skipped-count (1+ skipped-count)))
                        ;; Rename the file
                        (rename-file file new-filepath)
                        (message "Renamed: %s -> %s" filename new-filename)
                        (setq renamed-count (1+ renamed-count))))
                  ;; No title found
                  (message "Skipped %s: No title found" filename)
                  (setq skipped-count (1+ skipped-count))))
            (error
             (message "Error renaming %s: %s" filename (error-message-string err))
             (setq error-count (1+ error-count)))))))
    
    ;; Report results
    (message "Zettelkasten rename complete: %d renamed, %d skipped, %d errors" 
             renamed-count skipped-count error-count)
    
    ;; Update org-roam database if files were renamed
    (when (> renamed-count 0)
      (org-roam-db-sync))))

(defun hp/org-sanitize-title-for-filename (title)
  "Sanitize TITLE to be safe for use in filename."
  (let ((safe-title title))
    ;; Remove or replace problematic characters
    (setq safe-title (replace-regexp-in-string "[/\\:*?\"<>|]" "-" safe-title))
    ;; Replace multiple spaces with single dash
    (setq safe-title (replace-regexp-in-string "\\s-+" "-" safe-title))
    ;; Remove leading/trailing dashes and spaces
    (setq safe-title (replace-regexp-in-string "^[-\\s]+\\|[-\\s]+$" "" safe-title))
    ;; Convert to lowercase
    (setq safe-title (downcase safe-title))
    ;; Limit length to avoid filesystem issues
    (if (> (length safe-title) 100)
        (substring safe-title 0 100)
      safe-title)))

(defun hp/org-extract-tags-from-title (title)
  "Extract tags from TITLE string and return (clean-title . tags-list).
For example, 'DoomAI :tool:doomai:ai:' returns ('DoomAI' . '(tool doomai ai)')"
  (if (string-match "^\\([^:]+\\)\\(\\s-*:\\(?:[^:]+:\\)+\\)\\s-*$" title)
      (let ((clean-title (match-string 1 title))
            (tags-part (match-string 2 title)))
        ;; Extract individual tags from :tag1:tag2:tag3:
        (let ((tags '()))
          (string-match ":\\(.*\\):" tags-part)
          (when (match-string 1 tags-part)
            (setq tags (split-string (match-string 1 tags-part) ":" t)))
          (cons (string-trim clean-title) tags)))
    ;; No tags found, return title as-is
    (cons (string-trim title) nil)))

(defun hp/zettelkasten-timestamp-to-org-date (timestamp)
  "Convert Zettelkasten TIMESTAMP (YYYYMMDDHHmmss) to org date format.
For example, '20250803183700' returns '[2025-08-03 Sun 18:37]'"
  (when (string-match "^\\([0-9]\\{4\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)" timestamp)
    (let* ((year (match-string 1 timestamp))
           (month (match-string 2 timestamp))
           (day (match-string 3 timestamp))
           (hour (match-string 4 timestamp))
           (minute (match-string 5 timestamp))
           (date-string (format "%s-%s-%s %s:%s" year month day hour minute))
           (time (date-to-time date-string))
           (day-name (format-time-string "%a" time)))
      (format "[%s-%s-%s %s %s:%s]" year month day day-name hour minute))))

(defun hp/org-rename-single-file-to-zettelkasten (file)
  "Process and optionally rename a single FILE to Zettelkasten format.
If the file is already in Zettelkasten format, it will update the file content:
- Clean title by removing tags
- Add #+created: from filename timestamp
- Move tags to #+filetags:
- Add #+startup: overview if missing"
  (interactive "fSelect file to process: ")
  (let ((filename (file-name-nondirectory file)))
    (condition-case err
        (if (string-match "^\\([0-9]\\{14\\}\\)-.*\\.org$" filename)
            ;; File is already in Zettelkasten format - update its content
            (let* ((timestamp (match-string 1 filename))
                   (org-date (hp/zettelkasten-timestamp-to-org-date timestamp))
                   (file-content (with-temp-buffer
                                 (insert-file-contents file)
                                 (buffer-string)))
                   (lines (split-string file-content "\n"))
                   (title nil)
                   (clean-title nil)
                   (tags nil)
                   (has-created nil)
                   (has-filetags nil)
                   (has-startup nil)
                   (new-lines '()))
              
              ;; Process each line
              (dolist (line lines)
                (cond
                 ;; Process title line
                 ((string-match "^#\\+title:\\s-*\\(.+\\)$" line)
                  (setq title (match-string 1 line))
                  (let ((title-parts (hp/org-extract-tags-from-title title)))
                    (setq clean-title (car title-parts))
                    (setq tags (cdr title-parts))
                    (push (format "#+title: %s" clean-title) new-lines)))
                 
                 ;; Check for existing metadata
                 ((string-match "^#\\+created:" line)
                  (setq has-created t)
                  (push line new-lines))
                 
                 ((string-match "^#\\+filetags:" line)
                  (setq has-filetags t)
                  ;; If we have tags from title, update filetags
                  (if tags
                      (push (format "#+filetags: %s" (mapconcat 'identity tags " ")) new-lines)
                    (push line new-lines)))
                 
                 ((string-match "^#\\+startup:" line)
                  (setq has-startup t)
                  (push line new-lines))
                 
                 ;; Keep other lines as-is
                 (t (push line new-lines))))
              
              ;; Add missing metadata after title
              (setq new-lines (nreverse new-lines))
              (let ((title-pos (cl-position-if (lambda (line) (string-match "^#\\+title:" line)) new-lines)))
                (when title-pos
                  (let ((insert-pos (1+ title-pos))
                        (insertions '()))
                    
                    ;; Add missing metadata in reverse order (they'll be reversed when inserted)
                    (unless has-startup
                      (push "#+startup: overview" insertions))
                    
                    (unless has-filetags
                      (when tags
                        (push (format "#+filetags: %s" (mapconcat 'identity tags " ")) insertions)))
                    
                    (unless has-created
                      (when org-date
                        (push (format "#+created: %s" org-date) insertions)))
                    
                    ;; Insert the metadata
                    (dolist (insertion insertions)
                      (setq new-lines (append (cl-subseq new-lines 0 insert-pos)
                                            (list insertion)
                                            (cl-subseq new-lines insert-pos)))))))
              
              ;; Write the updated content back to file
              (with-temp-file file
                (insert (mapconcat 'identity new-lines "\n")))
              
              (message "Updated metadata in: %s" filename)
              
              ;; If file is open, revert it
              (let ((buf (get-file-buffer file)))
                (when buf
                  (with-current-buffer buf
                    (revert-buffer t t))))
              
              ;; Update org-roam database
              (org-roam-db-update-file))
          
          ;; File is not in Zettelkasten format - rename it
          (let ((title nil)
                (created-date nil))
            ;; Extract title and created date from file
            (with-temp-buffer
              (insert-file-contents file nil 0 1000)
              ;; Extract title
              (goto-char (point-min))
              (when (re-search-forward "^#\\+title:\\s-*\\(.+\\)$" nil t)
                (setq title (match-string 1)))
              ;; Extract created date if available
              (goto-char (point-min))
              (when (re-search-forward "^#\\+created:\\s-*\\[\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\)" nil t)
                (setq created-date (match-string 1))))
            
            (if title
                (let* ((title-parts (hp/org-extract-tags-from-title title))
                       (clean-title (car title-parts))
                       (timestamp (if created-date
                                    (format-time-string "%Y%m%d%H%M%S" 
                                                      (date-to-time (concat created-date " 00:00:00")))
                                  (format-time-string "%Y%m%d%H%M%S" 
                                                    (nth 5 (file-attributes file)))))
                       (sanitized-title (hp/org-sanitize-title-for-filename clean-title))
                       (new-filename (format "%s-%s.org" timestamp sanitized-title))
                       (new-filepath (expand-file-name new-filename 
                                                     (file-name-directory file))))
                  
                  (if (file-exists-p new-filepath)
                      (message "Cannot rename: Target file already exists - %s" new-filename)
                    (rename-file file new-filepath)
                    (message "Renamed: %s -> %s" filename new-filename)
                    ;; Process the renamed file to update its content
                    (hp/org-rename-single-file-to-zettelkasten new-filepath)))
              (message "Cannot rename: No title found in %s" filename))))
      (error
       (message "Error processing %s: %s" filename (error-message-string err))))))

(defun hp/org-process-zettelkasten-directory (directory)
  "Process all org files in DIRECTORY recursively to update metadata.
For files already in Zettelkasten format, updates their content:
- Cleans titles by removing tags
- Adds #+created: from filename timestamp
- Moves tags to #+filetags:
- Adds #+startup: overview if missing
For files not in Zettelkasten format, renames them first."
  (interactive "DDirectory: ")
  (let ((processed-count 0)
        (error-count 0))
    ;; Get all org files recursively
    (dolist (file (directory-files-recursively directory "\\.org$"))
      (unless (string= (file-name-nondirectory file) "index.org")
        (condition-case err
            (progn
              (message "Processing: %s" file)
              (hp/org-rename-single-file-to-zettelkasten file)
              (setq processed-count (1+ processed-count)))
          (error
           (message "Error processing %s: %s" file (error-message-string err))
           (setq error-count (1+ error-count))))))
    
    ;; Summary
    (message "Processing complete: %d files processed, %d errors" 
             processed-count error-count)
    
    ;; Update org-roam database if files were processed
    (when (> processed-count 0)
      (org-roam-db-sync))))

(defun hp/obsidian-to-org--copy-attachments (source-dir dest-dir)
  "Copy attachment directories from SOURCE-DIR to DEST-DIR."
  (dolist (attach-dir hp/obsidian-attachment-dirs)
    (let ((src (expand-file-name attach-dir source-dir))
          (dst (expand-file-name attach-dir dest-dir)))
      (when (file-directory-p src)
        (make-directory (file-name-directory dst) t)
        (copy-directory src dst t t t)))))

(defvar hp/obsidian-to-org-sync-timer nil
  "Timer for automatic Obsidian to Org synchronization.")

(defun hp/obsidian-to-org-auto-sync ()
  "Set up automatic synchronization of Obsidian vault to org-roam."
  (interactive)

  (when hp/obsidian-to-org-sync-timer
    (cancel-timer hp/obsidian-to-org-sync-timer))

  (setq hp/obsidian-to-org-sync-timer
        (run-with-timer
         300 ; 5 minutes initial delay
         1800 ; 30 minutes repeat
         (lambda ()
           (message "Starting Obsidian to Org sync...")
           (hp/obsidian-to-org-convert-directory
            obsidian-directory t)
           (message "Obsidian to Org sync completed."))))

  (message "Automatic Obsidian to Org sync enabled (every 30 minutes)"))

(defun hp/obsidian-to-org-stop-auto-sync ()
  "Stop automatic synchronization of Obsidian vault."
  (interactive)
  (when hp/obsidian-to-org-sync-timer
    (cancel-timer hp/obsidian-to-org-sync-timer)
    (setq hp/obsidian-to-org-sync-timer nil)
    (message "Automatic Obsidian to Org sync disabled")))

;; Add keybindings for conversion functions
(map! :leader
      :prefix "n"
      (:prefix ("i" . "import")
       (:prefix ("o" . "obsidian")
        :desc "Import current buffer" "b" #'hp/obsidian-to-org-convert-buffer
        :desc "Import single file" "f" #'hp/obsidian-to-org-convert-file
        :desc "Import directory" "d" #'hp/obsidian-to-org-convert-directory
        :desc "Import directory (recursive)" "D" #'hp/obsidian-to-org-convert-directory-recursive
        :desc "Generate index files" "i" #'hp/obsidian-to-org-generate-indices
        :desc "Convert & index (recursive)" "I" #'hp/obsidian-to-org-convert-and-index
        :desc "Rename to Zettelkasten (directory)" "z" #'hp/org-rename-to-zettelkasten
        :desc "Rename to Zettelkasten (file)" "Z" #'hp/org-rename-single-file-to-zettelkasten
        :desc "Process Zettelkasten directory (update metadata)" "p" #'hp/org-process-zettelkasten-directory
        :desc "Start auto sync" "s" #'hp/obsidian-to-org-auto-sync
        :desc "Stop auto sync" "S" #'hp/obsidian-to-org-stop-auto-sync)))
#+end_src

#+begin_src emacs-lisp
(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam
  :commands (org-roam-ui-mode))
#+end_src

***** Workspace creation
This is to automate creating a workspace for Org-roam

#+begin_src emacs-lisp
(after! (org-roam)
  (defadvice! yeet/org-roam-in-own-workspace-a (&rest _)
  "Open all roam buffers in there own workspace."
  :before #'org-roam-node-find
  :before #'org-roam-node-random
  :before #'org-roam-buffer-display-dedicated
  :before #'org-roam-buffer-toggle
  :before #'org-roam-dailies-goto-today
  (when (modulep! :ui workspaces)
    (+workspace-switch "Org-roam" t))))
#+end_src

***** Org-roam-protocol

#+begin_src emacs-lisp
(use-package! org-roam-protocol
  :after (org-roam org-roam-dailies org-protocol)
  :config
  (add-to-list
   'org-roam-capture-ref-templates
   `(;; Browser bookletmark template:
     ;; javascript:location.href =
     ;; 'org-protocol://roam-ref?template=w&ref='
     ;; + encodeURIComponent(location.href)
     ;; + '&title='
     ;; + encodeURIComponent(document.getElementsByTagName("h1")[0].innerText)
     ;; + '&hostname='
     ;; + encodeURIComponent(location.hostname)
     ("w" "webref" entry "* ${title} ([[${ref}][${hostname}]])\n%?"
      :target
      (file+head
       ,(concat org-roam-dailies-directory "%<%Y-%m>.org")
       ,(string-join
         '(":properties:"
           ":roam_refs: %^{Key}"
           ":end:"
           "#+title: %<%Y-%m>"
           "#+filetags: journal"
           "#+startup: overview"
           "#+created: %U"
           "") "\n"))
      :unnarrowed t))))
#+end_src

**** Org-roam and Org-agenda itegration
Integrating Org-roam and Org-agenda might be complicated, since Org-roam pushes us towards making many =.org= files, and Org-agenda works best with a few, big =.org= files.

The solution proposed in [[https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html][this blog post]] is to dynamically update the variable =org-agenda-files=, so that Org-agenda only check for Org-roam files that contains certain tags.
In my case, the tags that are marked for inspection are =tasked= and =schedule=.
Org-roam files are automatically marked with =tasked= as long as it has any =TODO= heading.
Files with =schedule= tags are designated manually.

#+begin_src emacs-lisp
(after! (org-agenda org-roam)
  (defun vulpea-task-p ()
    "Return non-nil if current buffer has any todo entry.

TODO entries marked as done are ignored, meaning the this
function returns nil if current buffer contains only completed
tasks."
    (seq-find                                 ; (3)
     (lambda (type)
       (eq type 'todo))
     (org-element-map                         ; (2)
         (org-element-parse-buffer 'headline) ; (1)
         'headline
       (lambda (h)
         (org-element-property :todo-type h)))))

  (defun vulpea-task-update-tag ()
    "Update task tag in the current buffer."
    (when (and (not (active-minibuffer-window))
               (vulpea-buffer-p))
      (save-excursion
        (goto-char (point-min))
        (let* ((tags (vulpea-buffer-tags-get))
               (original-tags tags))
          (if (vulpea-task-p)
              (setq tags (cons "task" tags))
            (setq tags (remove "task" tags)))

          ;; cleanup duplicates
          (setq tags (seq-uniq tags))

          ;; update tags if changed
          (when (or (seq-difference tags original-tags)
                    (seq-difference original-tags tags))
            (apply #'vulpea-buffer-tags-set tags))))))

  (defun vulpea-buffer-p ()
    "Return non-nil if the currently visited buffer is a note."
    (and buffer-file-name
         (string-prefix-p
          (expand-file-name (file-name-as-directory org-roam-directory))
          (file-name-directory buffer-file-name))))

  (defun vulpea-task-files ()
    "Return a list of note files containing 'task' tag." ;
    (seq-uniq
     (seq-map
      #'car
      (org-roam-db-query
       [:select [nodes:file]
        :from tags
        :left-join nodes
        :on (= tags:node-id nodes:id)
        :where (or (like tag (quote "%\"task\"%"))
                   (like tag (quote "%\"schedule\"%")))]))))

  (defun vulpea-agenda-files-update (&rest _)
    "Update the value of `org-agenda-files'."
    (setq org-agenda-files (vulpea-task-files)))

  (add-hook 'find-file-hook #'vulpea-task-update-tag)
  (add-hook 'before-save-hook #'vulpea-task-update-tag)

  (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
  (advice-add 'org-todo-list :before #'vulpea-agenda-files-update)

  ;; functions borrowed from `vulpea' library
  ;; https://github.com/d12frosted/vulpea/blob/6a735c34f1f64e1f70da77989e9ce8da7864e5ff/vulpea-buffer.el

  (defun vulpea-buffer-tags-get ()
    "Return filetags value in current buffer."
    (vulpea-buffer-prop-get-list "filetags" "[ :]"))

  (defun vulpea-buffer-tags-set (&rest tags)
    "Set TAGS in current buffer.

If filetags value is already set, replace it."
    (if tags
        (vulpea-buffer-prop-set
         "filetags" (concat ":" (string-join tags ":") ":"))
      (vulpea-buffer-prop-remove "filetags")))

  (defun vulpea-buffer-tags-add (tag)
    "Add a TAG to filetags in current buffer."
    (let* ((tags (vulpea-buffer-tags-get))
           (tags (append tags (list tag))))
      (apply #'vulpea-buffer-tags-set tags)))

  (defun vulpea-buffer-tags-remove (tag)
    "Remove a TAG from filetags in current buffer."
    (let* ((tags (vulpea-buffer-tags-get))
           (tags (delete tag tags)))
      (apply #'vulpea-buffer-tags-set tags)))

  (defun vulpea-buffer-prop-set (name value)
    "Set a file property called NAME to VALUE in buffer file.
If the property is already set, replace its value."
    (setq name (downcase name))
    (org-with-point-at 1
      (let ((case-fold-search t))
        (if (re-search-forward (concat "^#\\+" name ":\\(.*\\)")
                               (point-max) t)
            (replace-match (concat "#+" name ": " value) 'fixedcase)
          (while (and (not (eobp))
                      (looking-at "^[#:]"))
            (if (save-excursion (end-of-line) (eobp))
                (progn
                  (end-of-line)
                  (insert "\n"))
              (forward-line)
              (beginning-of-line)))
          (insert "#+" name ": " value "\n")))))

  (defun vulpea-buffer-prop-set-list (name values &optional separators)
    "Set a file property called NAME to VALUES in current buffer.
VALUES are quoted and combined into single string using
`combine-and-quote-strings'.
If SEPARATORS is non-nil, it should be a regular expression
matching text that separates, but is not part of, the substrings.
If nil it defaults to `split-string-default-separators', normally
\"[ \f\t\n\r\v]+\", and OMIT-NULLS is forced to t.
If the property is already set, replace its value."
    (vulpea-buffer-prop-set
     name (combine-and-quote-strings values separators)))

  (defun vulpea-buffer-prop-get (name)
    "Get a buffer property called NAME as a string."
    (org-with-point-at 1
      (when (re-search-forward (concat "^#\\+" name ": \\(.*\\)")
                               (point-max) t)
        (buffer-substring-no-properties
         (match-beginning 1)
         (match-end 1)))))

  (defun vulpea-buffer-prop-get-list (name &optional separators)
    "Get a buffer property NAME as a list using SEPARATORS.
If SEPARATORS is non-nil, it should be a regular expression
matching text that separates, but is not part of, the substrings.
If nil it defaults to `split-string-default-separators', normally
\"[ \f\t\n\r\v]+\", and OMIT-NULLS is forced to t."
    (let ((value (vulpea-buffer-prop-get name)))
      (when (and value (not (string-empty-p value)))
        (split-string-and-unquote value separators))))

  (defun vulpea-buffer-prop-remove (name)
    "Remove a buffer property called NAME."
    (org-with-point-at 1
      (when (re-search-forward (concat "\\(^#\\+" name ":.*\n?\\)")
                               (point-max) t)
        (replace-match ""))))
  )
#+end_src

**** Org-roam and citar integration
Citar integrates with Org-roam via =citar-org-roam.el=.
This makes the comand =citar-open-notes=  (bind to ~SPC n b~) use Org-roam's template system.
The bibliography notes created this way will be set up with proper =ID= and =ROAM_REFS= properties.
The integration also comes with a nice inteface when following an org citation

#+begin_src emacs-lisp
(use-package citar-org-roam
  :after citar org-roam
  :no-require
  :config
  (setq citar-org-roam-subdir "literature"
        citar-org-roam-note-title-template
        (string-join
         '("${author editor} (${year issued date}) ${title}"
           "#+filetags: literature"
           "#+startup: overview"
           "#+options: toc:2 num:t"
           "#+hugo_base_dir: ~/Dropbox/Blogs/hieutkt/"
           "#+hugo_section: ./notes"
           "#+hugo_custom_front_matter: :exclude true :math true"
           "#+hugo_custom_front_matter: :bibinfo '((doi .\"${doi}\") (isbn . \"${isbn}\") (url . \"${url}\") (year . \"${year}\") (month . \"${month}\") (date . \"${date}\") (author . \"${author}\") (journal . \"${journal}\"))"
           "#+hugo_series: \"Reading notes\""
           "#+hugo_tags:"
           ""
           "* What?"
           "* Why?"
           "* How?"
           "* And?"
           ) "\n"))
  (citar-org-roam-mode))
#+end_src

#+RESULTS:
: t

**** Backlinks count display

#+begin_src emacs-lisp
(defface hp/org-roam-count-overlay-face
  '((t :inherit org-list-dt :height 0.8))
  "Face for Org Roam count overlay.")

(defun hp/org-roam--count-overlay-make (pos count)
  (let* ((overlay-value (propertize
                         (concat "·" (format "%d" count) " ")
                         'face 'hp/org-roam-count-overlay-face 'display '(raise 0.2)))
         (ov (make-overlay pos pos (current-buffer) nil t)))
    (overlay-put ov 'roam-backlinks-count count)
    (overlay-put ov 'priority 1)
    (overlay-put ov 'after-string overlay-value)))

(defun hp/org-roam--count-overlay-remove-all ()
  (dolist (ov (overlays-in (point-min) (point-max)))
    (when (overlay-get ov 'roam-backlinks-count)
      (delete-overlay ov))))

(defun hp/org-roam--count-overlay-make-all ()
  (hp/org-roam--count-overlay-remove-all)
  (org-element-map (org-element-parse-buffer) 'link
    (lambda (elem)
      (when (string-equal (org-element-property :type elem) "id")
        (let* ((id (org-element-property :path elem))
               (count (caar
                       (org-roam-db-query
                        [:select (funcall count source)
                         :from links
                         :where (= dest $s1)
                         :and (= type "id")]
                        id))))
          (when (< 0 count)
            (hp/org-roam--count-overlay-make
             (org-element-property :end elem)
             count)))))))

(define-minor-mode hp/org-roam-count-overlay-mode
  "Display backlink count for org-roam links."
  :after-hook
  (if hp/org-roam-count-overlay-mode
      (progn
        (hp/org-roam--count-overlay-make-all)
        (add-hook 'after-save-hook #'hp/org-roam--count-overlay-make-all nil t))
    (hp/org-roam--count-overlay-remove-all)
    (remove-hook 'after-save-hook #'hp/org-roam--count-overlay-remove-all t)))

(add-hook 'org-mode-hook #'hp/org-roam-count-overlay-mode)
#+end_src
**** Carrying todos forwards
=org-roam-daily.el= provides a nice interface for daily journaling/note-taking in Emacs.
However, I want to make two related improvements.

The first is that, due to habitual behavior, I've ended up with an excessive number of empty journal files.
We write a handy command to automatically search for empty Org-files in a folder and delete them.

#+begin_src emacs-lisp
(defun hp/delete-empty-org-files (directory)
  "Delete Org files in DIRECTORY that contain only drawers or keywords.
This function is meant to clean out empty org-roam-dailies files."
  (interactive "DDirectory: ")
  (let ((files (directory-files-recursively directory "\\.org$")))
    (dolist (file files)
      (with-temp-buffer
        (insert-file-contents file)
        (goto-char (point-min))
        ;; Check if the file contains only drawers and keywords
        (if (not (re-search-forward "^[^#+:].+$" nil t))
            (delete-file file))))))
#+end_src

The second problem is something I want from Org-journal: =org-journal-carryover-items= which moves all TODO headings from a previous journal entry to today's.
We are going to implement that by advising =org-roam-dailies-goto-today=.

#+begin_src emacs-lisp
(defun hp/org-roam-get-previous-dailies-file ()
  "Get the file name for the most recent previous day's Org-roam dailies file."
  (let ((files (org-roam-dailies--list-files))
        (today (format-time-string "%Y-%m-%d")))
    (cond ((> (length files) 1)
           ;; Get the last and second-last files
           (let ((last-file (nth (- (length files) 1) files))
                 (second-last-file (nth (- (length files) 2) files)))
             ;; Check if the last file is for today
             (if (string-suffix-p (concat today ".org") last-file)
                 second-last-file
               last-file)))
          (t nil)))) ; Return nil if there's only one file (or none).


(defun hp/org-roam-migrate-todos (&rest _)
  "Migrate TODOs from the previous day's Org-roam file to today's file."
  (interactive)
  (let ((yesterday-file (hp/org-roam-get-previous-dailies-file))
        (today-file (buffer-file-name))
        (todo-regexp (concat "^\\*+ " (regexp-opt org-not-done-keywords))))
    (when (and yesterday-file (file-exists-p yesterday-file))
      (with-current-buffer (find-file-noselect yesterday-file)
        (goto-char (point-min))
        (while (re-search-forward todo-regexp nil t)
          (let ((element (org-element-at-point)))
            (when (eq (car element) 'headline)
              (let ((tree (buffer-substring (org-element-property :begin element)
                                            (org-element-property :end element))))
                (with-current-buffer (find-file-noselect today-file)
                  (goto-char (point-max))
                  (insert "\n" tree)
                  (save-buffer))
                ;; After inserting, delete the tree from the original file
                (delete-region (org-element-property :begin element)
                               (org-element-property :end element)))))
        (save-buffer)
        ;; Delete the empty file if needed
        (hp/delete-empty-org-files (file-name-directory yesterday-file))
        (message " Found TODO(s) from the last journal entry... carried them over!"))))
    (save-buffer)))
#+end_src

After carrying all todos forwards, this advise delete the previous journal entry if they ended up in an empty state.

#+begin_src emacs-lisp :tangle no
(advice-add 'org-roam-dailies-goto-today :after #'hp/org-roam-migrate-todos)
#+end_src

**** Handy command for journaling
The following comand create a new heading and add current time to it.

#+begin_src emacs-lisp
(defun hp/org-insert-timestamped-bullet ()
  "Insert a new bullet in Org-mode with the current timestamp."
  (interactive)
  (+org/insert-item-below 1)
  (insert (format-time-string "%H:%M ")))

;; Bind the function to a key combination, for example C-c t
(after! org
  (define-key org-mode-map (kbd "C-c t") 'hp/org-insert-timestamped-bullet))
#+end_src

#+RESULTS:
: hp/org-insert-timestamped-bullet
**** Org-Roam UI
#+begin_src emacs-lisp
(map! :leader
  :prefix "n"
    (:prefix ("r" . "roam")
      :desc "Open Org-Roam UI"      "u" #'org-roam-ui-open))
#+end_src
*** Org-download

#+begin_src emacs-lisp
(use-package! org-download
  :config
  (add-hook 'dired-mode-hook 'org-download-enable)
  ;; Change how inline images are displayed
  (setq org-download-display-inline-images nil))
#+end_src

** R
First programming language that I learnt.
Most of the time, the interation provided by ESS-mode is excellent and I can be productive with it.
Syntax-highlighting in =ess-r-mode= is not so spectacular, however.
Hopefully this will get better once =tree-sitter= is better integrated into Emacs.

#+begin_src emacs-lisp
(use-package! ess
  :config
  (set-popup-rules!
    '(("^\\*R:*\\*$" :side right :size 0.5 :ttl nil)))
  (setq ess-R-font-lock-keywords
        '((ess-R-fl-keyword:keywords . t)
          (ess-R-fl-keyword:constants . t)
          (ess-R-fl-keyword:modifiers . t)
          (ess-R-fl-keyword:fun-defs . t)
          (ess-R-fl-keyword:assign-ops . t)
          (ess-R-fl-keyword:%op% . t)
          (ess-fl-keyword:fun-calls . t)
          (ess-fl-keyword:numbers . t)
          (ess-fl-keyword:operators . t)
          (ess-fl-keyword:delimiters . t)
          (ess-fl-keyword:= . t)
          (ess-R-fl-keyword:F&T . t)))
  (map! (:map (ess-mode-map inferior-ess-mode-map)
         :g ";" #'ess-insert-assign)))
#+end_src

** Stata
Even though I try to use Stata as little as I can, sometimes it's unavoidable, especially in collaboration with applied economists.
I usually use the [[https://github.com/kylebarron/stata_kernel][Jupyter Stata kernel]] in these situations and it's decent, but sometimes I really miss the excellent editing environment that I have in Emacs.
In preparation, here's the little configurations if I ever decide to use Stata in Emacs:

#+begin_src emacs-lisp
(use-package! ess-stata-mode
  :after ess
  :config
  (setq inferior-STA-start-args ""
        inferior-STA-program (executable-find "stata")
        inferior-STA-program-name (executable-find "stata"))
  (add-to-list 'org-src-lang-modes '("jupyter-stata" . stata)))
#+end_src

** Python
Python is widely used and thus is extensively supported everywhere.
While I prefer Julia for numerical computing and R for econometrics and data visualization, Python is good in pretty much everything else.
I am happy with most the defaults given in Doom Emacs, so my custom configuration in this section is only minimal.

#+begin_src emacs-lisp
(use-package! python
  :config
  (set-popup-rules!
    '(("^\\*Python:*\\*$" :side right :size 0.5 :ttl nil))))
#+end_src

** Julia
=lsp-julia= tries to do the smart thing of auto-detecting the project environment as well as the correct path to the =LanguageServer.jl=.
I want it to do the dumb-but-simple thing of using the global installation of =LanguageServer.jl=.

#+begin_src emacs-lisp
(after! lsp-julia
  (setq lsp-julia-flags '("--startup-file=no" "--history-file=no")))
#+end_src

The rest of the configurations is straight forward.

#+begin_src emacs-lisp
(after! julia-mode
  (add-hook 'julia-mode-hook #'rainbow-delimiters-mode-enable))

(use-package! ob-julia
  :config
  (setq org-babel-julia-backend 'julia-snail))
#+end_src

Julia-snail is good.

#+begin_src emacs-lisp
(after! julia-snail
  (map! :map julia-snail-mode-map
        :g "C-c C-z" #'julia-snail
        :g "C-c C-l" #'julia-snail-send-line
        :map julia-repl-mode-map
        "C-c C-a" nil ;julia-snail-package-activate
        "C-c C-z" nil ;julia-snail
        "C-c C-c" nil ;julia-snail-send-top-level-form
        "C-c C-d" nil ;julia-snail-doc-lookup
        "C-c C-e" nil ;julia-snail-send-dwim
        "C-c C-k" nil ;julia-snail-send-buffer-file
        "C-c C-l" nil ;julia-snail-send-line
        :map vterm-mode-map
        :i "C-c C-z" nil
        :map markdown-view-mode-map
        :n "q" #'kill-this-buffer))
#+end_src

Some popup rules to make workflows more consistent.

#+begin_src emacs-lisp
(after! julia-repl
  (set-popup-rules!
  '(("^\\*julia.*\\*$" :side right :size 0.5 :ttl nil :quit nil)
    ("^\\*julia.*\\* documentation" :side bottom :size 0.4 :ttl nil)
    ("^\\*julia.*\\* mm" :select t :size #'+popup-shrink-to-fit :modeline t))))
#+end_src
** MATLAB
Rudimentary =matlab-mode= setups.

#+begin_src emacs-lisp
(use-package! matlab
  :commands (matlab-shell matlab-mode)
  :mode ("\\.m\\'" . matlab-mode)
  :hook (matlab-mode . rainbow-delimiters-mode)
  :config
  ;; LSP integration
  (add-to-list 'lsp-language-id-configuration '(matlab-mode . "matlab"))
  ;; setup matlab-shell
  (setq matlab-shell-command (executable-find "matlab"))
  (setq matlab-shell-command-switches '("-nodesktop"))
  ;; popup rules
  (set-popup-rules!
    '(("^\\*MATLAB.*\\*$" :side right :size 0.5 :ttl nil :quit nil)))
  ;; Keybindings
  (map! :map matlab-mode-map
        :g "C-c C-z" #'matlab-show-matlab-shell-buffer
        :map matlab-shell-mode-map
        :i "C-c C-z" #'other-window))
#+end_src

** Elfeeds

#+begin_src emacs-lisp
;; Load elfeed configuration
(load! "modules/hp-elfeed.el")
#+end_src

