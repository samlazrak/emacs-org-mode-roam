:PROPERTIES:
:ID:       21f80d7d-00f7-4959-9ea2-d7e4b680b272
:END:
#+title: My Doom Emacs configuration
#+startup: hideblocks content
#+filetags: :compilation:tool:blogs:
#+date: {{{modification-time(%Y-%m-%d)}}}
#+export_file_name: Doom-Emacs-config.md
#+options: toc:5 num:t H:5

* Introduction :ignore:
Emacs is certainly a strange piece of software.
It was created in the 1970s and is still in active development until this day, preserving weird concepts like "buffers" and "frame" and "fontification" in its documentation.
It calls the button =Ctrl= on modern keyboards as ~C~ and the =Alt= button as ~M~ (Meta).
In default settings, you copy text by pressing ~M-w~ , "kill" (in modern language: cut) by ~C-w~, and paste by ~C-y~.
In order to customize Emacs, you need to use a dedicated programming language called Emacs Lisp.

But despite all that, Emacs has become the central piece of software that I use to interact with my computer.
It's still just an text editor, but the one that you can spend hours to fine-tune it just the way you want it to be.
In my journey to learn Emacs, I also learnt a lot about how my computer works.
Along the way, I learnt how to code and I learnt how to write.
These days, I learn about stuffs beyond the computer, yet Emacs is still my friend.

This document describes how I set up my Emacs, in [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style, using a plain text format closely related to Emacs called [[https://orgmode.org/][Org-mode]].
The whole thing is contained in a [[https://raw.githubusercontent.com/hieutkt/dotfiles/main/emacs/.doom.d/config.org][single file]], from which both the Elisp code and this HTML document is generated.
This Emacs configuration is built based on a configuration framework called [[https://github.com/doomemacs/][Doom Emacs]], hence the name of this document.

* Prerequisites
** Reproducible information
This configuration is continuingly being improved.
I build my own Emacs from source in order to take advantage of some experimental features.
There are also =(packages! ...)=  calls to external Emacs packages that are not pinned to any specific version.
As such, there might be incompabilities if one blindly copies codes from this configurations.
Although I'll try to document which features are based on developing softwares and are likely to be changed in the future, it is inevitable that some bits of information are going to fall through the cracks.

In this section, I reiterate the relevant info about the version of the software I'm using here, in case someone finds this infomation useful.
Here's my current build of Emacs:

#+begin_src emacs-lisp :exports output :tangle no :eval t
(emacs-version)
#+end_src

#+RESULTS:
: GNU Emacs 29.1 (build 1, x86_64-pc-linux-gnu, GTK+ Version 3.24.38, cairo version 1.17.8)
:  of 2023-07-30

This Emacs is built with the following configuration options:

#+begin_src emacs-lisp :exports output :tangle no :eval t
system-configuration-options
#+end_src

#+RESULTS:
: --with-modules --with-json --with-mailutils --with-rsvg --with-native-compilation --with-xinput2 --with-gif --with-pgtk --with-tree-sitter

#+begin_src emacs-lisp :exports output :tangle no :eval t
system-configuration-features
#+end_src

#+RESULTS:
: ACL CAIRO DBUS FREETYPE GIF GLIB GMP GNUTLS GPM GSETTINGS HARFBUZZ JPEG JSON LCMS2 LIBSYSTEMD LIBXML2 MODULES NATIVE_COMP NOTIFY INOTIFY PDUMPER PGTK PNG RSVG SECCOMP SOUND SQLITE3 THREADS TIFF TOOLKIT_SCROLL_BARS TREE_SITTER WEBP XIM GTK3 ZLIB

* Fundamental setups
** Some good defaults

#+begin_src emacs-lisp
;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
(setq user-full-name "Sam Lazrak"
      user-mail-address "24284329+samlazrak@users.noreply.github.com"
      ;;default-input-method 'vietnamese-telex
      +doom-dashboard-banner-dir doom-user-dir
      +doom-dashboard-banner-file "emacse.svg"
      +doom-dashboard-banner-size 400
      +doom-dashboard-banner-padding '(0 . 2))

;; Suppress deprecated cl package warnings
(setq byte-compile-warnings '(not cl-functions obsolete))

;; Turn on abbrev mode
(setq-default abbrev-mode t)

;; Start Doom fullscreen
(add-to-list 'default-frame-alist '(width . 92))
(add-to-list 'default-frame-alist '(height . 40))
;; (add-to-list 'default-frame-alist '(alpha 97 100))

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(if (and (string-match-p "Windows" (getenv "PATH")) (not IS-WINDOWS))
    (setq dropbox-directory "/mnt/c/Users/m3/Dropbox/")
  (setq dropbox-directory "~/Dropbox/"))

(setq org-directory (concat dropbox-directory "Notes/"))


;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type 'relative)
(remove-hook! '(text-mode-hook) #'display-line-numbers-mode)

(setq frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name))))))
#+end_src

** Theme
I have done a fair share of theme-hopping. In the end, I always come back to a variant of the [[https://github.com/morhetz/gruvbox][Gruvbox color scheme]].
If you are viewing this on my website, you may find that this color scheme is ubiquitous here.

#+begin_src emacs-lisp
;; The custom doom-everforest theme is a green-accented variant of gruvbox-material
(setq doom-theme 'doom-gruvbox)

(use-package! doom-modeline
  :config
  (setq doom-modeline-persp-name t))
#+end_src

** Font configs
*** Font choices
[[https://typeof.net/Iosevka/][Iosevka]] is a great font with good coverage (excellent if you count its extension Sarasa Gothic).
The narrow glyphs allow us to save some precious screen real estate.
This is particularly useful for multitasking with multiple windows open.
For example, my notetaking workflow involved having a small (not maximized) Emacs window, along with one or several windows for pdf viewers, often on a 13-inch laptop screen.
You can see the benefit here.
I cannot go back to non-narrow fonts anymore.

It's even better that it allows me to cherry-pick glyphs that I like (or don't like).
My customized Iosevka is based on the Ubuntu Mono style variant (SS12).
This style brings me that nostalgic feel of my first linux distribution.
The underscore =_= is more pronounced, which I like.
The stylized letters (e.g. see =l=, =m=, =n=, =i=, =j=,...) bring forth a humanist, comfy yet quirky aesthetic.

Below is my =private-build-plans.toml=, made with this [[https://typeof.net/Iosevka/customizer][lovely customizer]].
The font compilation takes quite a while, though.
Make sure to consult with the [[https://github.com/be5invis/Iosevka/blob/main/doc/custom-build.md][instructions]]:

#+begin_src toml :tangle no
[buildPlans.iosevka-custom]
family = "Iosevka Custom"
spacing = "normal"
serifs = "sans"
noCvSs = true
export-glyph-names = false

  [buildPlans.iosevka-custom.variants]
  inherits = "ss12"

    [buildPlans.iosevka-custom.variants.design]
    v = "straight-serifed"
    lower-alpha = "crossing"
    capital-gamma = "top-right-serifed"
    zero = "dotted"
    ampersand = "et-toothed"
    lig-ltgteq = "slanted"

  [buildPlans.iosevka-custom.ligations]
  inherits = "julia"
#+end_src

*** Setups
Now to set all this up:

#+begin_src emacs-lisp
(when (doom-font-exists-p "FiraMono Nerd Font Mono")
    (setq doom-font                (font-spec :name "FiraMono Nerd Font Mono" :size 16)))
(when (doom-font-exists-p "FiraCode Nerd Font Propo")
    (setq doom-variable-pitch-font (font-spec :name "FiraCode Nerd Font Propo"  :size 18)))
(when (doom-font-exists-p "Noto Color Emoji")
    (setq doom-emoji-font          (font-spec :name "Noto Color Emoji")))
(when (doom-font-exists-p "FiraMono Nerd Font Mono")
    (setq doom-symbol-font         (font-spec :name "FiraMono Nerd Font Mono")))
#+end_src

Fallback font for non-ascii glyphs:

#+begin_src emacs-lisp
(use-package! unicode-fonts
  :config
  ;; Common math symbols
  (dolist (unicode-block '("Mathematical Alphanumeric Symbols"))
    (push "JuliaMono Nerd Font Mono" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  (dolist (unicode-block '("Greek and Coptic"))
    (push "FiraMono Nerd Font Mono" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  ;; CJK characters
  (dolist (unicode-block '("CJK Unified Ideographs" "CJK Symbols and Punctuation" "CJK Radicals Supplement" "CJK Compatibility Ideographs"))
    (push "Sarasa Mono SC" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  (dolist (unicode-block '("Hangul Syllables" "Hangul Jamo Extended-A" "Hangul Jamo Extended-B"))
    (push "Sarasa Mono K" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  ;; Emojis
  (dolist (unicode-block '("Miscellaneous Symbols"))
    (push "Noto Color Emoji" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  ;; Other unicode block
  (dolist (unicode-block '("Braille Patterns"))
    (push "FiraMono Nerd Font Mono" (cadr (assoc unicode-block unicode-fonts-block-font-mapping))))
  )
#+end_src

*** Ligatures
Emacs (since version 28 I think) handles ligatures pretty well.
However, sometimes we still need to manually fix some ligature composition:

#+begin_src emacs-lisp :tangle no
;; For Iosevka
;; (set-char-table-range composition-function-table ?+ '(["\\(?:+[\\*]\\)" 0 font-shape-gstring]))
(set-char-table-range composition-function-table ?* '(["\\(?:\\*?[=+>]\\)" 0 font-shape-gstring]))
;; (set-char-table-range composition-function-table ?= '(["\\(?:=?[=\\*]\\)" 0 font-shape-gstring]))
;; (set-char-table-range composition-function-table ?= '(["\\(?:=?[\\*:]\\)" 0 font-shape-gstring]))
;; (set-char-table-range composition-function-table ?: '(["\\(?::=\\)" 0 font-shape-gstring]))
;; For Alegreya/Alegreya Sans
(set-char-table-range composition-function-table ?f '(["\\(?:ff?[fijltkbh]\\)" 0 font-shape-gstring]))
;; (set-char-table-range composition-function-table ?T '(["\\(?:Th\\)" 0 font-shape-gstring]))
#+end_src

*** Mixed- and fixed-pitch fonts
We should take care of =mixed-pitch-mode= here, too:

#+begin_src emacs-lisp
(use-package! mixed-pitch
  :hook ((org-mode      . mixed-pitch-mode)
         (org-roam-mode . mixed-pitch-mode))
  :config
  (pushnew! mixed-pitch-fixed-pitch-faces
            'warning
            'org-drawer 'org-cite-key 'org-list-dt 'org-hide
            'corfu-default)
  (setq mixed-pitch-set-height t))
#+end_src
** Icons
Some nerd-icons related stuffs

#+begin_src emacs-lisp
(use-package! nerd-icons-ibuffer
  :ensure t
  :hook (ibuffer-mode . nerd-icons-ibuffer-mode))

;; (use-package! magit-file-icons
;;   :init
;;   (magit-file-icons-mode 1))
#+end_src

** Slightly transparent Emacs
Emacs version 29 added a new frame parameter for "true" transparency, which means that only the blackground is transparent while the text is not.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(alpha-background . 96))
#+end_src

I set Emacs to be slightly transparent.
With this setting, I can put Emacs at full screen while still being able to read from the windows behind it.
This is very useful when screen real-estate is scarce (which is always the case!)
** Modeline
Some tweaks to =doom-modeline=:
#+begin_src emacs-lisp
(setq doom-modeline-height 35)
#+end_src

Show page number when viewing PDFs:

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon 'mdicon "nf-md-file_pdf_box" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive))))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

Recent version of [[https://github.com/seagle0128/doom-modeline/pull/622][doom-modeline]] features [[github:rainstormstudio/nerd-icons.el][nerd-icons.el]] instead of [[github:domtronn/all-the-icons.el][all-the-icons.el]].
I like this change, however different parts of Doom are still using =all-the-icons= under the hood.
Some custom configurations is needed for now.

#+begin_src emacs-lisp
(use-package! nerd-icons
  :custom
  (nerd-icons-font-family "FiraMono Nerd Font Mono")
  (nerd-icons-scale-factor 1.2)
  (nerd-icons-default-adjust 0)
  (doom-modeline-major-mode-icon t))
#+end_src

** Narrowing and center buffer contents
On larger screens I like buffer contents to not exceed a certain width and are centered.
=olivetti-mode= solves this problem nicely.
There is also an =auto-olivetti-mode=  which automatically turns on =olivetti-mode= in most buffers.

#+begin_src emacs-lisp
(use-package! olivetti
  :config
  (setq-default olivetti-body-width 130)
  (add-hook 'mixed-pitch-mode-hook  
            (lambda () 
              (when (and (bound-and-true-p olivetti-mode)
                         (or (not (numberp olivetti-body-width))
                             (eq olivetti-body-width 'unspecified)))
                (setq-local olivetti-body-width 90)))))

(use-package! auto-olivetti
  :custom
  (auto-olivetti-enabled-modes '(text-mode prog-mode helpful-mode ibuffer-mode image-mode))
  :config
  ;; Fix for olivetti-body-width being set to 'unspecified
  (defadvice! +olivetti-fix-unspecified-width-a (&rest _)
    "Fix olivetti-body-width when it gets set to 'unspecified."
    :before #'olivetti-set-window
    (when (or (not (numberp olivetti-body-width))
              (eq olivetti-body-width 'unspecified))
      (setq-local olivetti-body-width 130)))
  
  ;; Remove the error handling approach and try a different strategy
  ;; This wrapper suppresses the error messages while preserving functionality
  (defun olivetti--suppress-errors (orig-fn &rest args)
    "Suppress olivetti error messages."
    (let ((inhibit-message t)
          (message-log-max nil))
      (condition-case nil
          (apply orig-fn args)
        (error nil))))
  
  ;; Apply error suppression to the functions that generate errors
  (advice-add 'olivetti-set-window :around #'olivetti--suppress-errors)
  (advice-add 'olivetti-normalize-width :around #'olivetti--suppress-errors)
  
  (auto-olivetti-mode))
#+end_src
** Git gutter
The =diff= changes are reflected in the left fringe.
However, I find them to be a little bit too intrusive, so let's change how they looks by blending the colors into the background a little bit

#+begin_src emacs-lisp
(use-package! diff-hl
  :config
  (custom-set-faces!
    `((diff-hl-change)
      :foreground ,(doom-blend (doom-color 'bg) (doom-color 'blue) 0.5))
    `((diff-hl-insert)
      :foreground ,(doom-blend (doom-color 'bg) (doom-color 'green) 0.5)))
  )
#+end_src
** Alignment in popup fix (=which-key= and =marginalia=)
The default character for ellipsis breaks alignment in =which-key= tables, so let's fix that

#+begin_src emacs-lisp
(use-package! which-key
  :init
  (setq which-key-ellipsis "..."))

#+end_src

Similarly for marginalia

#+begin_src emacs-lisp
(setq marginalia--ellipsis "...")
#+end_src
** Precision scrolling

Turn on pixel scrolling:

#+begin_src emacs-lisp
(pixel-scroll-precision-mode t)
#+end_src

The following code replace all scrolling and recenter commands with the precision-scrolling version.

#+begin_src emacs-lisp
(defun hp/pixel-recenter (&optional arg redisplay)
  "Similar to `recenter' but with pixel scrolling.
ARG and REDISPLAY are identical to the original function."
  ;; See the links in line 6676 in window.c for
  (when-let* ((current-pixel (pixel-posn-y-at-point))
              (target-pixel (if (numberp arg)
                                (* (line-pixel-height) arg)
                              (* 0.5 (window-body-height nil t))))
              (distance-in-pixels 0)
              (pixel-scroll-precision-interpolation-total-time
               (/ pixel-scroll-precision-interpolation-total-time 2.0)))
    (setq target-pixel
          (if (<= 0 target-pixel)
              target-pixel
            (- (window-body-height nil t) (abs target-pixel))))
    (setq distance-in-pixels (- target-pixel current-pixel))
    (condition-case err
        (pixel-scroll-precision-interpolate distance-in-pixels nil 1)
      (error (message "[hp/pixel-recenter] %s" (error-message-string err))))
    (when redisplay (redisplay t))))

(defun hp/pixel-scroll-up (&optional arg)
  "(Nearly) drop-in replacement for `scroll-up'."
  (cond
   ((eq this-command 'scroll-up-line)
    (funcall (ad-get-orig-definition 'scroll-up) (or arg 1)))
   (t
    (unless (eobp) ; Jittery window if trying to go down when already at bottom
      (pixel-scroll-precision-interpolate
       (- (* (line-pixel-height)
             (or arg (- (window-text-height) next-screen-context-lines))))
       nil 1)))))

(defun hp/pixel-scroll-down (&optional arg)
  "(Nearly) drop-in replacement for `scroll-down'."
  (cond
   ((eq this-command 'scroll-down-line)
    (funcall (ad-get-orig-definition 'scroll-down) (or arg 1)))
   (t
    (pixel-scroll-precision-interpolate
     (* (line-pixel-height)
        (or arg (- (window-text-height) next-screen-context-lines)))
     nil 1))))

(add-hook 'pixel-scroll-precision-mode-hook
          (lambda ()
            (cond
             (pixel-scroll-precision-mode
              (advice-add 'scroll-up :override 'hp/pixel-scroll-up)
              (advice-add 'scroll-down :override 'hp/pixel-scroll-down)
              (advice-add 'recenter :override 'hp/pixel-recenter))
             (t
              (advice-remove 'scroll-up 'hp/pixel-scroll-up)
              (advice-remove 'scroll-down 'hp/pixel-scroll-down)
              (advice-remove 'recenter 'hp/pixel-recenter)))))
#+end_src

* Editing configurations
** Handy functions
The =hp/fill-to-end= function function in Emacs Lisp fills the remaining space on the current line with a specified character until the line reaches the column defined by =fill-column=.
When executed interactively, the function prompts the user to input the character to be used for filling.
The cursor position is temporarily saved and restored to its original location after the line is filled.

#+begin_src emacs-lisp
(defun hp/fill-to-end (char)
  (interactive "cFill Character:")
  (save-excursion
    (end-of-line)
    (while (< (current-column) fill-column)
      (insert-char char))))
#+end_src

** Evil
#+begin_src emacs-lisp
(use-package! evil
  :init
  (setq evil-move-beyond-eol t
        evil-move-cursor-back nil))

(use-package! evil-escape
  :config
  (setq evil-esc-delay 0.25))

(use-package! evil-vimish-fold
  :config
  (global-evil-vimish-fold-mode))

(use-package! evil-goggles
  :init
  (setq evil-goggles-enable-change t
        evil-goggles-enable-delete t
        evil-goggles-pulse         t
        evil-goggles-duration      0.5)
  :config
  (custom-set-faces!
    `((evil-goggles-yank-face evil-goggles-surround-face)
      :background ,(doom-blend (doom-color 'blue) (doom-color 'bg-alt) 0.5)
      :extend t)
    `(evil-goggles-paste-face
      :background ,(doom-blend (doom-color 'green) (doom-color 'bg-alt) 0.5)
      :extend t)
    `(evil-goggles-delete-face
      :background ,(doom-blend (doom-color 'red) (doom-color 'bg-alt) 0.5)
      :extend t)
    `(evil-goggles-change-face
      :background ,(doom-blend (doom-color 'orange) (doom-color 'bg-alt) 0.5)
      :extend t)
    `(evil-goggles-commentary-face
      :background ,(doom-blend (doom-color 'grey) (doom-color 'bg-alt) 0.5)
      :extend t)
    `((evil-goggles-indent-face evil-goggles-join-face evil-goggles-shift-face)
      :background ,(doom-blend (doom-color 'yellow) (doom-color 'bg-alt) 0.25)
      :extend t)
    ))
#+end_src
*** Hack: load evil keybindings
For some reasons =evil= keybindings are usually not loaded along with emacs.
The simple solution is forcing emacs to load this file.

#+begin_src emacs-lisp
(defun hp/load-evil-keybindings ()
  (interactive)
  (load-file "~/.config/emacs/modules/config/default/+evil-bindings.el"))

(add-hook 'doom-after-init-hook #'hp/load-evil-keybindings)
#+end_src

** Completions
*** Enable corfu in the minibuffer
Having completion in the minibuffer is useful for when you want to run small elisp command to temporary modify the state of Emacs.
This has been getting more and more useful the longer I have been using Emacs.

#+begin_src emacs-lisp
(use-package! corfu
  :config
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion
      (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                  corfu-popupinfo-delay nil)
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer))
#+end_src

*** Narrow down queries for non-ASCII characters
Sometimes my queries return results in Vietnamese which include letters with diacritics (e.g. =ă= or =đ= or =ê=).
In these cases, I want to be able to narrow the search down by typing their ASCII equivalents (e.g. =a= or =d= or =e=).
The implementation is simple: set matching styles in =orderless.el= to include the function =char-fold-to-regexp=.

#+begin_src emacs-lisp
(use-package! orderless
  :config
  (add-to-list 'orderless-matching-styles 'char-fold-to-regexp))
#+end_src

*** Smaller popup text
Automatic documentation popup while autocompleting is nice, but let's reduce the font size a little bit so that it doesn't cover the screen too much and makes it easier to skim for information:

#+begin_src emacs-lisp :tangle no
(custom-set-faces! '((corfu-popupinfo) :height 0.9))
#+end_src

*** Icons
Kind-icon adds icons to =corfu= completions based on the =:company-kind= property.
Let's add this properties to those that don't provide them.

#+begin_src emacs-lisp
(after! org-roam
  ;; Define advise
  (defun hp/org-roam-capf-add-kind-property (orig-fun &rest args)
    "Advice around `org-roam-complete-link-at-point' to add :company-kind property."
    (let ((result (apply orig-fun args)))
      (append result '(:company-kind (lambda (_) 'org-roam)))))
  ;; Wraps around the relevant functions
  (advice-add 'org-roam-complete-link-at-point :around #'hp/org-roam-capf-add-kind-property)
  (advice-add 'org-roam-complete-everywhere :around #'hp/org-roam-capf-add-kind-property))

(after! citar
  ;; Define advise
  (defun hp/citar-capf-add-kind-property (orig-fun &rest args)
    "Advice around `org-roam-complete-link-at-point' to add :company-kind property."
    (let ((result (apply orig-fun args)))
      (append result '(:company-kind (lambda (_) 'reference)))))
  ;; Wraps around the relevant functions
  (advice-add 'citar-capf :around #'hp/citar-capf-add-kind-property))
#+end_src

Now, we can implement custom icons for Org-roam completions:

#+begin_src emacs-lisp
(after! (org-roam nerd-icons-corfu)
  (add-to-list
   'nerd-icons-corfu-mapping
   '(org-roam :style "cod" :icon "notebook" :face font-lock-type-face)))
#+end_src

** Language server protocol (LSP)
#+begin_src emacs-lisp
(use-package! lsp-ui
  :config
  (setq lsp-ui-doc-delay 2
        lsp-ui-doc-max-width 80)
  (setq lsp-signature-function 'lsp-signature-posframe))
#+end_src

** Yasnippet

#+begin_src emacs-lisp
(use-package! yasnippet
  :config
  ;; It will test whether it can expand, if yes, change cursor color
  (defun hp/change-cursor-color-if-yasnippet-can-fire (&optional field)
    (interactive)
    (setq yas--condition-cache-timestamp (current-time))
    (let (templates-and-pos)
      (unless (and yas-expand-only-for-last-commands
                   (not (member last-command yas-expand-only-for-last-commands)))
        (setq templates-and-pos (if field
                                    (save-restriction
                                      (narrow-to-region (yas--field-start field)
                                                        (yas--field-end field))
                                      (yas--templates-for-key-at-point))
                                  (yas--templates-for-key-at-point))))
      (set-cursor-color (if (and templates-and-pos (first templates-and-pos)
                                 (eq evil-state 'insert))
                            (doom-color 'red)
                          (face-attribute 'default :foreground)))))
  :hook (post-command . hp/change-cursor-color-if-yasnippet-can-fire))
#+end_src

** Citations

#+begin_src emacs-lisp
(use-package! citar
  :hook
  (org-mode . citar-capf-setup)
  :config
  (setq
   citar-bibliography (list (concat org-directory "/References/zotero.bib"))
   citar-notes-paths (list(concat org-directory "/Org-roam/literature/"))
   citar-library-paths (list (concat org-directory "/Org-roam/"))
   citar-file-variable "file"
   citar-symbol-separator "  "
   ;; The global bibliography source may be set to something,
   ;; but now let's set it on a per-file basis
   ;; org-cite-global-bibliography citar-bibliography
   )
  ;; Search contents of PDFs
  (after! (embark pdf-occur)
    (defun citar/search-pdf-contents (keys-entries &optional str)
      "Search pdfs."
      (interactive (list (citar-select-refs)))
      (let ((files (citar-file--files-for-multiple-entries
                    (citar--ensure-entries keys-entries)
                    citar-library-paths
                    '("pdf")))
            (search-str (or str (read-string "Search string: "))))
        (pdf-occur-search files search-str t)))
    ;; with this, you can exploit embark's multitarget actions, so that you can run `embark-act-all`
    (add-to-list 'embark-multitarget-actions #'citar/search-pdf-contents)))
#+end_src
** Workspaces
#+begin_src emacs-lisp
(defadvice! hp/config-in-its-own-workspace (&rest _)
  "Open Elfeeds in its own workspace."
  :before #'doom/find-file-in-private-config
  (when (modulep! :ui workspaces)
    (+workspace-switch "Configs" t)))
#+end_src

* Major modes and language-specific configurations
** Org-mode
I came to Emacs for coding, but eventually what kept me using it is Org-mode.
In fact, I spend most of my time in an Org-mode buffer.
It's just that good.
*** Basics

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-highlight-links
        '(bracket angle plain tag date footnote)
        org-image-align 'center)
  ;; Setup custom links
  (+org-init-custom-links-h))
#+end_src

Need to check if ellipsis icon works properly before committing:

#+begin_src emacs-lisp
(after! (org nerd-icons)
  (setq org-ellipsis ""))
#+end_src

*** Org-capture
#+begin_src emacs-lisp
(after! org-capture
  (setq org-capture-templates
        `(("t" "Todo" entry (file+headline ,(concat org-directory "tasks.org") "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("n" "Note" entry (file+datetree ,(concat org-directory "notes.org"))
           "* %?\nEntered on %U\n  %i\n  %a")
          ("j" "Journal" entry (file+datetree ,(concat org-directory "journal.org"))
           "* %?\nEntered on %U\n  %i\n  %a")
          ("m" "Meeting" entry (file+headline ,(concat org-directory "meetings.org") "Meetings")
           "* %? :meeting:\n  %U\n  %i\n  %a")
          ("i" "Idea" entry (file+headline ,(concat org-directory "ideas.org") "Ideas")
           "* %?\n  %U\n  %i\n  %a")
          ("w" "Web Link" entry (file+headline ,(concat org-directory "links.org") "Links")
           "* %?\n  %U\n  %c\n  %i"))))
#+end_src

*** Org-tempo
#+begin_src emacs-lisp
(use-package! org-tempo
  :after org
  :config
  )
#+end_src
**** Org-Pandoc Import/Export
#!begin_src emacs-lisp
(use-package! org-pandoc-import :after org)
#+end_src

*** Visual-related configs
Since I spend most of my time writing in Org-mode, might as well make it looks nice.
**** Custom faces

#+begin_src emacs-lisp
(after! org
  ;; Set some faces
  (custom-set-faces!
    `((org-quote)
      :foreground ,(doom-color 'blue) :extend t)
    `((org-block-begin-line org-block-end-line)
      :background ,(doom-color 'bg)))
  ;; Change how image previews are shown
  (setq org-image-actual-width (min (/ (display-pixel-width) 3) 800)))
#+end_src

Emacs version 29 can now tell the difference between 'regular' or  'normal' font weights and 'medium' weights.
Let's use the medium weights for org-mode headings.

#+begin_src emacs-lisp :tangle no
(after! org-mode
  (custom-set-faces!
    `((org-document-title)
      :foreground ,(face-attribute 'org-document-title :foreground)
      :height 1.4 :weight 'semi-bold)
    `((org-level-1)
      :foreground ,(face-attribute 'outline-1 :foreground)
      :height 1.3 :weight 'semi-bold)
    `((org-level-2)
      :foreground ,(face-attribute 'outline-2 :foreground)
      :height 1.2 :weight 'semi-bold)
    `((org-level-3)
      :foreground ,(face-attribute 'outline-3 :foreground)
      :height 1.1 :weight 'semi-bold)
    `((org-level-4)
      :foreground ,(face-attribute 'outline-4 :foreground)
      :weight 'semi-bold)
    `((org-level-5)
      :foreground ,(face-attribute 'outline-5 :foreground)
      :weight 'semi-bold)))
#+end_src

**** Font-lock settings

#+begin_src emacs-lisp
(after! org
  ;; Custom regex fontifications
  (font-lock-add-keywords 'org-mode
                          '(("^\\(?:[  ]*\\)\\(?:[-+]\\|[ ]+\\*\\|\\(?:[0-9]+\\|[A-Za-z]\\)[.)]\\)?[ ]+"
                             . 'fixed-pitch)))
  (font-lock-add-keywords 'org-mode '(("(\\?)" . 'error)))

  ;; Highlight first letter of a paragraph
  ;; (font-lock-add-keywords 'org-mode '(("^\\(?:\n\\)\\([[:digit:][:upper:][:lower:]]\\)" . 'org-warning)))
  )
#+end_src

**** Prettify symbols
Org-mode syntax supports having two consecutive dashes =--= as to be exported as the en-dash (=–=) and three consecutive dashes =---= to be exported as the em-dash (=—=).
It's good to have these symbols automatically prettified in an Org-buffer too.

[[file:pics/org-em-dash.png]]

However, the problem is that =prettify-symbol-mode= doesn't replace the symbols right after a word or inside quotes, which are the two major use-case for the em-dash (=—=).
To remedy this problem, we need to write a custom function and set it to =prettify-symbols-compose-predicate=.

#+begin_src emacs-lisp
(after! org
  ;; Prettification should ignore preceding letters
  (defun prettify-symbols-compose-in-text-mode-p (start end _match)
    "Similar to `prettify-symbols-default-compose-p' but ignore letters or words."
    ;; Check that the chars should really be composed into a symbol.
    (let* ((syntaxes-beg (if (memq (char-syntax (char-after start)) '(?_))
                             '(?_) '(?. ?\\)))
           (syntaxes-end (if (memq (char-syntax (char-before end)) '(?_))
                             '(?_) '(?. ?\\))))
      (not (or (memq (char-syntax (or (char-before start) ?\s)) syntaxes-beg)
               (memq (char-syntax (or (char-after end) ?\s)) syntaxes-end)
               ;; (nth 8 (syntax-ppss))
               (org-in-src-block-p)
               ))))
  ;; Replace two consecutive hyphens with the em-dash
  (defun hp/org-mode-load-prettify-symbols ()
    (interactive)
    (pushnew! prettify-symbols-alist
              '(":PROPERTIES:" . "")
              '("--"  . "–") '("---" . "—")
              '("(?)" . "") '("(?)." . ".") '("(?)," . ","))
    (modify-syntax-entry ? " ")
    (prettify-symbols-mode 1)
    ;; Now, set the value of this
    (setq-local prettify-symbols-compose-predicate 'prettify-symbols-compose-in-text-mode-p)
    )
  (when (not IS-WINDOWS)
    (add-hook 'org-mode-hook 'hp/org-mode-load-prettify-symbols)))
#+end_src
**** Turn off highlighting current line
Highlight mode is nice.
However, in an Org-mode buffer, I feel like it might be too much.
Let's turn off =hl-line-mode= in text buffers for now.

#+begin_src emacs-lisp
(add-hook 'text-mode-hook (lambda () (hl-line-mode -1)))
#+end_src

**** Org-modern and svg-tag-mode
=org-modern= is really cool -- especially when combined with =svg-tag-mode=.
The only downside is it doesn't play well with =org-indent-mode= (for now).

#+begin_src emacs-lisp
(use-package! org-modern
  :hook (org-mode . org-modern-mode)
  :config
  (setq
   ;; Edit settings
   org-catch-invisible-edits 'show-and-error
   org-special-ctrl-a/e t
   org-insert-heading-respect-content t
   ;; Appearance
   org-modern-radio-target    '("❰" t "❱")
   org-modern-internal-target '("↪ " t "")
   org-modern-todo nil
   org-modern-tag nil
   org-modern-timestamp t
   org-modern-progress nil
   org-modern-priority nil
   org-modern-horizontal-rule "──────────"
   org-modern-hide-stars "·"
   org-modern-star 'fold
   org-modern-fold-stars '(("⁛" . "⁖"))
   org-modern-keyword "‣"
   org-modern-list '((43 . "•")
                     (45 . "–")
                     (42 . "↪")))
  (custom-set-faces!
    `((org-modern-tag)
      :background ,(doom-blend (doom-color 'blue) (doom-color 'bg) 0.1)
      :foreground ,(doom-color 'grey))
    `((org-modern-radio-target org-modern-internal-target)
      :inherit 'default :foreground ,(doom-color 'blue)))
  )
#+end_src

The configurations for =svg-tag-mode= go here, too:

#+begin_src emacs-lisp
(use-package! svg-tag-mode
  :config
  (defconst date-re "[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}")
  (defconst time-re "[0-9]\\{2\\}:[0-9]\\{2\\}")
  (defconst day-re "[A-Za-z]\\{3\\}")
  (defconst day-time-re (format "\\(%s\\)? ?\\(%s\\)?" day-re time-re))

  (defun svg-progress-percent (value)
    (svg-image (svg-lib-concat
                (svg-lib-progress-bar
                 (/ (string-to-number value) 100.0) nil
                 :height 0.8 :foreground (doom-color 'fg) :background (doom-color 'bg)
                 :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
                (svg-lib-tag (concat value "%") nil
                             :height 0.8 :foreground (doom-color 'fg) :background (doom-color 'bg)
                             :stroke 0 :margin 0)) :ascent 'center))

  (defun svg-progress-count (value)
    (let* ((seq (mapcar #'string-to-number (split-string value "/")))
           (count (float (car seq)))
           (total (float (cadr seq))))
      (svg-image (svg-lib-concat
                  (svg-lib-progress-bar (/ count total) nil
                                        :foreground (doom-color 'fg)
                                        :background (doom-color 'bg) :height 0.8
                                        :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
                  (svg-lib-tag value nil
                               :foreground (doom-color 'fg)
                               :background (doom-color 'bg)
                               :stroke 0 :margin 0 :height 0.8)) :ascent 'center)))

  (set-face-attribute 'svg-tag-default-face nil :family "Alegreya Sans")
  (setq svg-tag-tags
        `(;; Progress e.g. [63%] or [10/15]
          ("\\(\\[[0-9]\\{1,3\\}%\\]\\)" . ((lambda (tag)
                                              (svg-progress-percent (substring tag 1 -2)))))
          ("\\(\\[[0-9]+/[0-9]+\\]\\)" . ((lambda (tag)
                                            (svg-progress-count (substring tag 1 -1)))))
          ;; Task priority e.g. [#A], [#B], or [#C]
          ("\\[#A\\]" . ((lambda (tag) (svg-tag-make tag :face 'error :inverse t :height .85
                                                     :beg 2 :end -1 :margin 0 :radius 10))))
          ("\\[#B\\]" . ((lambda (tag) (svg-tag-make tag :face 'warning :inverse t :height .85
                                                     :beg 2 :end -1 :margin 0 :radius 10))))
          ("\\[#C\\]" . ((lambda (tag) (svg-tag-make tag :face 'org-todo :inverse t :height .85
                                                     :beg 2 :end -1 :margin 0 :radius 10))))
          ;; Keywords
          ("TODO" . ((lambda (tag) (svg-tag-make tag :inverse t :height .85 :face 'org-todo))))
          ("HOLD" . ((lambda (tag) (svg-tag-make tag :height .85 :face 'org-todo))))
          ("DONE\\|STOP" . ((lambda (tag) (svg-tag-make tag :inverse t :height .85 :face 'org-done))))
          ("NEXT\\|WAIT" . ((lambda (tag) (svg-tag-make tag :inverse t :height .85 :face '+org-todo-active))))
          ("REPEAT\\|EVENT\\|PROJ\\|IDEA" .
           ((lambda (tag) (svg-tag-make tag :inverse t :height .85 :face '+org-todo-project))))
          ("REVIEW" . ((lambda (tag) (svg-tag-make tag :inverse t :height .85 :face '+org-todo-onhold))))))

  :hook (org-mode . svg-tag-mode)
  )
#+end_src

**** Org-appear
=org-appear= for seemless look:

#+begin_src emacs-lisp
(use-package! org-appear
  :hook
  (org-mode . org-appear-mode)
  :config
  (setq org-hide-emphasis-markers t
        org-appear-autolinks 'just-brackets))
#+end_src

**** Org-CSL-activate
Similarly, for CSL citations formatting in an Org buffer:

#+begin_src emacs-lisp
(use-package! oc-csl-activate
  :config
  (setq org-cite-activate-processor 'csl-activate)
  (setq org-cite-csl-activate-use-document-style t)
  (setq org-cite-csl-activate-use-document-locale t)
  (add-hook 'org-mode-hook
            (lambda ()
              (cursor-sensor-mode 1)
              (org-cite-csl-activate-render-all))))
#+end_src
**** General
#+begin_src emacs-lisp
(use-package! ox
  :config
  (setq org-export-with-tags nil)
  ;; Auto export acronyms as small caps
  ;; Copied from tecosaur

  (defun org-export-filter-text-acronym (text backend _info)
    "Wrap suspected acronyms in acronyms-specific formatting.
Treat sequences of 2+ capital letters (optionally succeeded by \"s\") as an acronym.
Ignore if preceeded by \";\" (for manual prevention) or \"\\\" (for LaTeX commands).

TODO abstract backend implementations."
    (let ((base-backend
           (cond
            ;; ((org-export-derived-backend-p backend 'latex) 'latex)
            ((org-export-derived-backend-p backend 'html) 'html)))
          (case-fold-search nil))
      (when base-backend
        (replace-regexp-in-string
         "[;\\\\]?\\b[A-Z][A-Z]+s?\\(?:[^A-Za-z]\\|\\b\\)"
         (lambda (all-caps-str)
           (cond ((equal (aref all-caps-str 0) ?\\) all-caps-str)                ; don't format LaTeX commands
                 ((equal (aref all-caps-str 0) ?\;) (substring all-caps-str 1))  ; just remove not-acronym indicator char ";"
                 (t (let* ((final-char (if (string-match-p "[^A-Za-z]" (substring all-caps-str -1 (length all-caps-str)))
                                           (substring all-caps-str -1 (length all-caps-str))
                                         nil)) ; needed to re-insert the [^A-Za-z] at the end
                           (trailing-s (equal (aref all-caps-str (- (length all-caps-str) (if final-char 2 1))) ?s))
                           (acr (if final-char
                                    (substring all-caps-str 0 (if trailing-s -2 -1))
                                  (substring all-caps-str 0 (+ (if trailing-s -1 (length all-caps-str)))))))
                      (pcase base-backend
                        ('html (concat "<span class='smallcap'>" (s-downcase acr) "</span>" (when trailing-s "<small>s</small>") final-char)))))))
         text t t))))

  (add-to-list 'org-export-filter-plain-text-functions
               #'org-export-filter-text-acronym)

  ;; We won't use `org-export-filter-headline-functions' because it
  ;; passes (and formats) the entire section contents. That's no good.

  (defun org-html-format-headline-acronymised (todo todo-type priority text tags info)
    "Like `org-html-format-headline-default-function', but with acronym formatting."
    (org-html-format-headline-default-function
     todo todo-type priority (org-export-filter-text-acronym text 'html info) tags info))
  (setq org-html-format-headline-function #'org-html-format-headline-acronymised)
  )
#+end_src

This allows ignoring headlines when exporting by adding the tag =:ignore:=  to an Org heading.

#+begin_src emacs-lisp
(use-package! ox-extra
  :config
  (ox-extras-activate '(ignore-headlines)))
#+end_src
**** Exporting behavior of special blocks
***** General behaviors
#+begin_src emacs-lisp
(use-package! org-special-block-extras
  :after org
  :hook (org-mode . org-special-block-extras-mode)
  :config
  (setq org-special-block-add-html-extra nil))
#+end_src

***** Theorems, proof, definitions
#+begin_src emacs-lisp
(after! org-special-block-extras
  ;; Theorem
  (org-defblock theorem
   (name "")
   (format "{{< notice info \"Theorem: %s\" >}}\n%s\n{{< /notice >}}"
           (if (eq name "") "" (format "[%s]" name)) contents))
  ;; Proposition
  (org-defblock proposition
   (name "")
   (format "{{< notice info \"Proposition: %s\" >}}\n%s\n{{< /notice >}}"
           (if (eq name "") "" (format "[%s]" name)) contents))
  ;; Lemma
  (org-defblock lemma
   (name "")
   (format "{{< notice info \"Lemma: %s\" >}}\n%s\n{{< /notice >}}"
           (if (eq name "") "" (format "[%s]" name)) contents))
  ;;Definitions
  (org-defblock definition
   (name "")
   (format "{{< notice info \"Definition: %s\" >}}\n%s\n{{< /notice >}}"
           (if (eq name "") "" (format "[%s]" name)) contents))
  )
#+end_src
***** Simpler =details= blocks

#+begin_src emacs-lisp
(after! org-special-block-extras
  (org-defblock detail-summary
   (title "")
   (format (pcase backend
             (_ "<details>\n<summary>%s</summary>%s </details>"))
           title contents)))
#+end_src
***** Notices

#+begin_src emacs-lisp
(after! org-special-block-extras
  (org-defblock warning
   (frame-title "Warning")
   (format "{{< notice warning \"%s\" >}}\n%s\n{{< /notice >}}"
    frame-title contents))


  (org-defblock info
   (frame-title "Info")
   (format "{{< notice info \"%s\" >}}\n%s\n{{< /notice >}}"
    frame-title contents))


  (org-defblock tips
   (frame-title "Tips")
   (format "{{< notice tip \"%s\" >}}\n%s\n{{< /notice >}}"
    frame-title contents))
  )
#+end_src

**** Block color overlays
Since we're are overdoing it, let's make these blocks /slightly colorful/!

#+begin_src emacs-lisp
(after! org-special-block-extras
  (defface hp/org-special-blocks-tips-face
    `((t :background ,(doom-blend (doom-color 'teal) (doom-color 'bg) 0.1) :extend t))
    "Face for tip blocks")
  (defface hp/org-special-blocks-info-face
    `((t :background ,(doom-blend (doom-color 'blue) (doom-color 'bg) 0.1) :extend t))
    "Face for info blocks")
  (defface hp/org-special-blocks-warning-face
    `((t :background ,(doom-blend (doom-color 'orange) (doom-color 'bg) 0.1) :extend t))
    "Face for warning blocks")
  (defface hp/org-special-blocks-note-face
    `((t :background ,(doom-blend (doom-color 'violet) (doom-color 'bg) 0.1) :extend t))
    "Face for warning blocks")
  (defface hp/org-special-blocks-question-face
    `((t :background ,(doom-blend (doom-color 'green) (doom-color 'bg) 0.1) :extend t))
    "Face for warning blocks")
  (defface hp/org-special-blocks-error-face
    `((t :background ,(doom-blend (doom-color 'red) (doom-color 'bg) 0.1) :extend t))
    "Face for warning blocks")

  (defun hp/org-add-overlay-tips-blocks ()
    "Apply overlays to #+begin_tips blocks in the current buffer."
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\\(\\#\\+begin_tips\\)" nil t)
        (let* ((beg (match-beginning 0))
               (end (if (re-search-forward "^\\(\\#\\+end_tips\\)" nil t)
                        (1+ (line-end-position))
                      (point-max)))
               (ov (make-overlay beg end)))
          (overlay-put ov 'face 'hp/org-special-blocks-tips-face)))))

  (defun hp/org-add-overlay-info-blocks ()
    "Apply overlays to #+begin_info blocks in the current buffer."
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\\(\\#\\+begin_\\(?:info\\|theorem\\)\\)" nil t)
        (let* ((beg (match-beginning 0))
               (end (if (re-search-forward "^\\(\\#\\+end_\\(?:info\\|theorem\\)\\)" nil t)
                        (1+ (line-end-position))
                      (point-max)))
               (ov (make-overlay beg end)))
          (overlay-put ov 'face 'hp/org-special-blocks-info-face)))))

  (defun hp/org-add-overlay-warning-blocks ()
    "Apply overlays to #+begin_warning blocks in the current buffer."
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\\(\\#\\+begin_warning\\)" nil t)
        (let* ((beg (match-beginning 0))
               (end (if (re-search-forward "^\\(\\#\\+end_warning\\)" nil t)
                        (1+ (line-end-position))
                      (point-max)))
               (ov (make-overlay beg end)))
          (overlay-put ov 'face 'hp/org-special-blocks-warning-face)))))

  (defun hp/org-add-overlay-note-blocks ()
    "Apply overlays to #+begin_note blocks in the current buffer."
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\\(\\#\\+begin_\\(?:note\\|definition\\)\\)" nil t)
        (let* ((beg (match-beginning 0))
               (end (if (re-search-forward "^\\(\\#\\+end_\\(?:note\\|definition\\)\\)" nil t)
                        (1+ (line-end-position))
                      (point-max)))
               (ov (make-overlay beg end)))
          (overlay-put ov 'face 'hp/org-special-blocks-note-face)))))

  (defun hp/org-add-overlay-question-blocks ()
    "Apply overlays to #+begin_question blocks in the current buffer."
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^\\(\\#\\+begin_\\(?:question\\|proposition\\)\\)" nil t)
        (let* ((beg (match-beginning 0))
               (end (if (re-search-forward "^\\(\\#\\+end_\\(?:question\\|proposition\\)\\)" nil t)
                        (1+ (line-end-position))
                      (point-max)))
               (ov (make-overlay beg end)))
          (overlay-put ov 'face 'hp/org-special-blocks-question-face)))))


  (add-hook! '(org-mode-hook yas-after-exit-snippet-hook)
             '(hp/org-add-overlay-tips-blocks
               hp/org-add-overlay-info-blocks
               hp/org-add-overlay-warning-blocks
               hp/org-add-overlay-note-blocks
               hp/org-add-overlay-question-blocks)))
#+end_src

*** Org-agenda
#+begin_src emacs-lisp
(use-package! org-agenda
  :config
  ;; Setting the TODO keywords
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"                    ;What needs to be done
           "NEXT(n)"                    ;A project without NEXTs is stuck
           "|"
           "DONE(d)")
          (sequence
           "REPEAT(e)"                    ;Repeating tasks
           "|"
           "DONE")
          (sequence
           "HOLD(h)"                    ;Task is on hold because of me
           "PROJ(p)"                    ;Contains sub-tasks
           "WAIT(w)"                    ;Tasks delegated to others
           "REVIEW(r)"                  ;Daily notes that need reviews
           "IDEA(i)"                    ;Daily notes that need reviews
           "|"
           "STOP(c)"                    ;Stopped/cancelled
           "EVENT(m)"                   ;Meetings
           ))
        org-todo-keyword-faces
        '(("[-]"  . +org-todo-active)
          ("NEXT" . +org-todo-active)
          ("[?]"  . +org-todo-onhold)
          ("REVIEW" . +org-todo-onhold)
          ("HOLD" . +org-todo-cancel)
          ("PROJ" . +org-todo-project)
          ("DONE"   . +org-todo-cancel)
          ("STOP" . +org-todo-cancel)))
  ;; Appearance
  (setq org-agenda-span 20
        org-agenda-prefix-format       " %i %?-2 t%s"
        org-agenda-todo-keyword-format "%-6s"
        org-agenda-current-time-string "ᐊ┈┈┈┈┈┈┈ Now"
        org-agenda-time-grid '((today require-timed remove-match)
                               (0900 1200 1400 1700 2100)
                               "      "
                               "┈┈┈┈┈┈┈┈┈┈┈┈┈")
        )
  ;; Clocking
  (setq org-clock-persist 'history
        org-columns-default-format "%50ITEM(Task) %10CLOCKSUM %16TIMESTAMP_IA"
        org-agenda-start-with-log-mode t)
  (org-clock-persistence-insinuate))


(use-package! org-habit
  :config
  (setq org-habit-show-all-today t))
#+end_src

*** Org-babel
Org-babel might be nice, but editing inside an Org-buffer means that you have to give up all the nice functionalities of the individual language's major more.
Luckily, we have  =org-edit-special= (bound to ~SPC m '~ in Doom Emacs).

#+begin_src emacs-lisp
(setq org-src-window-setup 'current-window)
#+end_src

Now, to set this up for different languages:

#+begin_src emacs-lisp
(use-package! ob-julia
  :commands org-babel-execute:julia)
#+end_src

*** Org-cite
#+begin_src emacs-lisp
(use-package! oc
  :config
  (setq org-cite-csl-styles-dir (concat dropbox-directory "Documents/Zotero/styles/")
        org-cite-export-processors '((t . (csl "chicago-author-date.csl")))))
#+end_src

*** Org-roam
**** Fundamental settings
***** Customizing main interface
#+begin_src emacs-lisp
(use-package! org-roam
  :after org
  :init
  (setq org-roam-directory "~/Documents/Roam/"
        org-roam-completion-everywhere nil
        ;;Functions tags are special types of tags which tells what the node are for
        ;;In the future, this should probably be replaced by categories
        hp/org-roam-function-tags '("compilation" "argument" "journal" "concept" "tool" "data" "bio" "literature" "event" "website"))
  :config
  ;; Org-roam interface
  (cl-defmethod org-roam-node-hierarchy ((node org-roam-node))
    "Return the node's TITLE, as well as it's HIERACHY."
    (let* ((title (org-roam-node-title node))
           (olp (mapcar (lambda (s) (if (> (length s) 10) (concat (substring s 0 10)  "...") s)) (org-roam-node-olp node)))
           (level (org-roam-node-level node))
           (filetitle (org-roam-get-keyword "TITLE" (org-roam-node-file node)))
           (filetitle-or-name (if filetitle filetitle (file-name-nondirectory (org-roam-node-file node))))
           (shortentitle (if (> (length filetitle-or-name) 20) (concat (substring filetitle-or-name 0 20)  "...") filetitle-or-name))
           (separator (concat " " (nerd-icons-octicon "nf-oct-chevron_right") " ")))
      (cond
       ((= level 1) (concat (propertize (format "=level:%d=" level) 'display
                                        (nerd-icons-faicon "nf-fa-file" :face 'nerd-icons-dyellow))
                            (propertize shortentitle 'face 'org-roam-olp) separator title))
       ((= level 2) (concat (propertize (format "=level:%d=" level) 'display
                                        (nerd-icons-faicon "nf-fa-file" :face 'nerd-icons-dsilver))
                            (propertize (concat shortentitle separator (string-join olp separator)) 'face 'org-roam-olp)
                            separator title))
       ((> level 2) (concat (propertize (format "=level:%d=" level) 'display
                                        (nerd-icons-faicon "nf-fa-file" :face 'org-roam-olp))
                            (propertize (concat shortentitle separator (string-join olp separator)) 'face 'org-roam-olp) separator title))
       (t (concat (propertize (format "=level:%d=" level) 'display
                              (nerd-icons-faicon "nf-fa-file" :face 'nerd-icons-yellow))
                  (if filetitle title (propertize filetitle-or-name 'face 'nerd-icons-dyellow)))))))

  (cl-defmethod org-roam-node-functiontag ((node org-roam-node))
    "Return the FUNCTION TAG for each node. These tags are intended to be unique to each file, and represent the note's function.
        journal data literature"
    (let* ((tags (seq-filter (lambda (tag) (not (string= tag "ATTACH"))) (org-roam-node-tags node))))
      (concat
       ;; Argument or compilation
       (cond
        ((member "argument" tags)
         (propertize "=f:argument=" 'display
                     (nerd-icons-mdicon "nf-md-forum" :face 'nerd-icons-dred)))
        ((member "compilation" tags)
         (propertize "=f:compilation=" 'display
                     (nerd-icons-mdicon "nf-md-format_list_text" :face 'nerd-icons-dyellow)))
        (t (propertize "=f:empty=" 'display
                       (nerd-icons-codicon "nf-cod-remove" :face 'org-hide))))
       ;; concept, bio, data or event
       (cond
        ((member "concept" tags)
         (propertize "=f:concept=" 'display
                     (nerd-icons-mdicon "nf-md-blur" :face 'nerd-icons-dblue)))
        ((member "tool" tags)
         (propertize "=f:tool=" 'display
                     (nerd-icons-mdicon "nf-md-tools" :face 'nerd-icons-dblue)))
        ((member "bio" tags)
         (propertize "=f:bio=" 'display
                     (nerd-icons-octicon "nf-oct-people" :face 'nerd-icons-dblue)))
        ((member "event" tags)
         (propertize "=f:event=" 'display
                     (nerd-icons-codicon "nf-cod-symbol_event" :face 'nerd-icons-dblue)))
        ((member "data" tags)
         (propertize "=f:data=" 'display
                     (nerd-icons-mdicon "nf-md-chart_arc" :face 'nerd-icons-dblue)))
        (t (propertize "=f:nothing=" 'display
                       (nerd-icons-codicon "nf-cod-remove" :face 'org-hide))))
       ;; literature
       (cond
        ((member "literature" tags)
         (propertize "=f:literature=" 'display
                     (nerd-icons-mdicon "nf-md-bookshelf" :face 'nerd-icons-dcyan)))
        ((member "website" tags)
         (propertize "=f:website=" 'display
                     (nerd-icons-mdicon "nf-md-web" :face 'nerd-icons-dsilver)))
        (t (propertize "=f:nothing=" 'display
                       (nerd-icons-codicon "nf-cod-remove" :face 'org-hide))))
       ;; journal
       )))

  (cl-defmethod org-roam-node-othertags ((node org-roam-node))
    "Return the OTHER TAGS of each notes."
    (let* ((tags (seq-filter (lambda (tag) (not (string= tag "ATTACH"))) (org-roam-node-tags node)))
           (specialtags hp/org-roam-function-tags)
           (othertags (seq-difference tags specialtags 'string=)))
       (propertize
        (string-join
         (append '(" ") othertags)
         (propertize "#" 'display
                     (nerd-icons-faicon "nf-fa-hashtag" :face 'nerd-icons-dgreen)))
        'face 'nerd-icons-dgreen)))

  (cl-defmethod org-roam-node-backlinkscount ((node org-roam-node))
    (let* ((count (caar (org-roam-db-query
                         [:select (funcall count source)
                          :from links
                          :where (= dest $s1)
                          :and (= type "id")]
                         (org-roam-node-id node)))))
      (if (> count 0)
          (concat (propertize "=has:backlinks=" 'display
                              (nerd-icons-mdicon "nf-md-link" :face 'nerd-icons-blue)) (format "%d" count))
        (concat " " (propertize "=not-backlinks=" 'display
                                (nerd-icons-mdicon "nf-md-link" :face 'org-hide))  " "))))

  (cl-defmethod org-roam-node-directories ((node org-roam-node))
    (if-let ((dirs (file-name-directory (file-relative-name (org-roam-node-file node) org-roam-directory))))
        (concat
         (if (string= "journal/" dirs)
             (nerd-icons-mdicon	"nf-md-fountain_pen_tip" :face 'nerd-icons-dsilver)
           (nerd-icons-mdicon	"nf-md-folder" :face 'nerd-icons-dsilver))
         (propertize (string-join (f-split dirs) "/") 'face 'nerd-icons-dsilver) " ")
      ""))

  (defun +marginalia--time-colorful (time)
    (let* ((seconds (float-time (time-subtract (current-time) time)))
           (color (doom-blend
                   (face-attribute 'marginalia-on :foreground nil t)
                   (face-attribute 'marginalia-off :foreground nil t)
                   (/ 1.0 (log (+ 3 (/ (+ 1 seconds) 345600.0)))))))
      ;; 1 - log(3 + 1/(days + 1)) % grey
      (propertize (marginalia--time time) 'face (list :foreground color :slant 'italic))))

  (setq org-roam-node-display-template
        (concat  "${backlinkscount:16} ${functiontag} ${directories}${hierarchy}${othertags} ")
        org-roam-node-annotation-function
        (lambda (node) (+marginalia--time-colorful (org-roam-node-file-mtime node))))
  )
#+end_src

Sorting =org-roam-node-find= by last modified time seems the most intuitive for me.

#+begin_src emacs-lisp
(defun org-roam-node-find-by-mtime ()
  (find-file
   (org-roam-node-file
    (org-roam-node-read nil nil #'org-roam-node-read-sort-by-file-mtime))))

(advice-add 'org-roam-node-find :override #'org-roam-node-find-by-mtime)
#+end_src

***** Capture templates
#+begin_src emacs-lisp
(use-package! org-roam-capture
  :config
  (setq org-roam-capture-templates
        `(("d" "default" plain "%?"
           :target
           (file+head "${slug}_%<%Y-%m-%d--%H-%M-%S>.org"
                      "#+title: ${title}\n#+created: %U\n#+filetags: %(completing-read \"Function tags: \" hp/org-roam-function-tags)\n#+startup: overview")
           :unnarrowed t))))

(use-package! org-roam-dailies
  :config
  (setq org-roam-dailies-directory "journal/"
        org-roam-dailies-capture-templates
        '(("d" "daily" entry "* %?"
           :target
           (file+head "%<%Y-%m-%d>.org"
                      "#+title: %<%Y-%m-%d %a>\n#+filetags: journal\n#+startup: content\n#+created: %U\n\n")
           :immediate-finish t)))
  (map! :leader
        :prefix "n"
        (:prefix ("j" . "journal")
         :desc "Arbitrary date" "d" #'org-roam-dailies-goto-date
         :desc "Today"          "j" #'org-roam-dailies-goto-today
         :desc "Tomorrow"       "m" #'org-roam-dailies-goto-tomorrow
         :desc "Yesterday"      "y" #'org-roam-dailies-goto-yesterday)))
;; Obsidian
(map! :leader
        :prefix "n"
        (:prefix ("O" . "obsidian")
         ;; Obsidian functions
         :desc "Obsidian jump to note" "j" #'obsidian-jump
         :desc "Obsidian capture note" "c" #'obsidian-capture
         :desc "Obsidian insert wikilink" "l" #'obsidian-insert-wikilink
         :desc "Obsidian insert link" "L" #'obsidian-insert-link
         :desc "Obsidian follow link" "f" #'obsidian-follow-link-at-point
         :desc "Obsidian update metadata" "u" #'obsidian-update
         :desc "Obsidian tag find" "t" #'obsidian-tag-find
         :desc "Obsidian change vault" "v" #'obsidian-change-vault
         :desc "Obsidian specify path" "p" #'obsidian-specify-path
         :desc "Open vault with treemacs" "V" #'hp/obsidian-open-vault-with-treemacs))


;; Custom function to open Obsidian vault with treemacs
(defun hp/obsidian-open-vault-with-treemacs ()
  "Open the Obsidian vault directory, split window, and launch treemacs."
  (interactive)
  ;; Open the vault directory in dired
  (find-file obsidian-directory)
  ;; Split window vertically
  (split-window-right)
  ;; Open treemacs
  (treemacs)
  ;; Navigate treemacs to the vault directory
  (treemacs-find-file obsidian-directory))

;; Obsidian package configuration
(use-package! obsidian
  :ensure t
  :defer t
  :commands (obsidian-jump
             obsidian-capture
             obsidian-insert-wikilink
             obsidian-insert-link
             obsidian-follow-link-at-point
             obsidian-update
             obsidian-tag-find
             obsidian-change-vault
             obsidian-specify-path
             hp/obsidian-open-vault-with-treemacs)
  :config
  (setq obsidian-directory "~/Documents/Obsidian/Obsidian/")
  (global-obsidian-mode))
#+end_src

**** Obsidian to Org-mode Conversion
These functions handle converting Obsidian markdown files to org-mode format, preserving
wikilinks, attachments, and metadata.

#+begin_src emacs-lisp
;; Core conversion functions for Obsidian to Org-mode
(defvar hp/obsidian-org-output-dir (concat org-roam-directory "obsidian-import/")
  "Directory where converted Obsidian files will be stored.")

(defvar hp/obsidian-attachment-dirs '("attachments" "Attachments" "assets" "Assets")
  "List of common attachment directory names in Obsidian vaults.")

(defun hp/obsidian-to-org--extract-data (content)
  "Extract minimal data from Obsidian CONTENT.
Returns a plist with :title :tags :created :body."
  (let ((data '()))
    (if (string-match "^---\n\\(\\(?:.*\n\\)*?\\)---\n" content)
        (let* ((frontmatter (match-string 1 content))
               (body (substring content (match-end 0))))
          ;; Extract body content - use setq to ensure we update the outer data
          (setq data (plist-put data :body body))
          ;; Parse only essential frontmatter fields
          (with-temp-buffer
            (insert frontmatter)
            (goto-char (point-min))
            (while (re-search-forward "^\\([^:]+\\):\\s-*\\(.+\\)$" nil t)
              (let* ((key (downcase (match-string 1)))
                     (value (match-string 2)))
                ;; Clean up values
                (setq value (replace-regexp-in-string "^[\"']\\|[\"']$" "" value))
                (cond
                 ;; Extract title
                 ((string= key "title")
                  (setq data (plist-put data :title value)))
                 ;; Extract tags - handle both arrays and strings
                 ((string= key "tags")
                  (cond
                   ;; YAML array format: [tag1, tag2]
                   ((string-match "\\[\\(.+\\)\\]" value)
                    (let ((tags-str (match-string 1 value)))
                      (setq tags-str (replace-regexp-in-string "\\s-*,\\s-*" " " tags-str))
                      (setq tags-str (replace-regexp-in-string "^\\s-*-\\s-*" "" tags-str))
                      (setq data (plist-put data :tags (split-string tags-str)))))
                   ;; YAML list format with dashes
                   ((string-match "^\\s*-\\s*" value)
                    (setq data (plist-put data :tags (list (replace-regexp-in-string "^\\s*-\\s*" "" value)))))
                   ;; Simple string
                   (t (setq data (plist-put data :tags (split-string value))))))
                 ;; Extract created date
                 ((member key '("created" "date"))
                  (setq data (plist-put data :created value))))))))
      ;; No frontmatter, just use the content as body
      (setq data (plist-put data :body content)))
    data))

(defun hp/obsidian-to-org--rebuild-org-file (data filename)
  "Rebuild a clean org file from extracted DATA.
DATA should be a plist with :title :tags :created :body.
FILENAME is used as fallback for title."
  (let* ((title (or (plist-get data :title) 
                    (file-name-sans-extension filename)))
         (tags (plist-get data :tags))
         (created (plist-get data :created))
         (body (or (plist-get data :body) ""))
         (org-content ""))
    
    ;; Build minimal properties drawer with just ID
    (setq org-content ":PROPERTIES:\n")
    (setq org-content (concat org-content (format ":ID:       %s\n" (org-id-new))))
    (setq org-content (concat org-content ":END:\n"))
    
    ;; Add title with inline tags if present
    (if (and tags (listp tags) (> (length tags) 0))
        (let* ((valid-tags (seq-filter (lambda (tag) (and tag (stringp tag))) tags))
               (tag-string (when valid-tags
                            (mapconcat (lambda (tag) 
                                        (concat ":" (replace-regexp-in-string "\\s-+" "" tag) ":"))
                                      valid-tags " "))))
          (if (and tag-string (not (string-empty-p tag-string)))
              (setq org-content (concat org-content (format "#+title: %s %s\n" title tag-string)))
            (setq org-content (concat org-content (format "#+title: %s\n" title)))))
      (setq org-content (concat org-content (format "#+title: %s\n" title))))
    
    ;; Add created date if present
    (when (and created (stringp created))
      (let ((date-str (if (string-match "\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\)" created)
                         (match-string 1 created)
                       created)))
        (setq org-content (concat org-content (format "#+created: [%s]\n" date-str)))))
    
    ;; Add filetags if present
    (when (and tags (listp tags) (> (length tags) 0))
      (let* ((valid-tags (seq-filter (lambda (tag) (and tag (stringp tag))) tags))
             (filetags (when valid-tags
                        (string-join (mapcar (lambda (tag) 
                                              (replace-regexp-in-string "\\s-+" "" tag))
                                            valid-tags) " "))))
        (when (and filetags (not (string-empty-p filetags)))
          (setq org-content (concat org-content (format "#+filetags: %s\n" filetags))))))
    
    ;; Add startup directive
    (setq org-content (concat org-content "#+startup: overview\n\n"))
    
    ;; Add body content
    (setq org-content (concat org-content body))
    
    org-content))

(defun hp/obsidian-to-org--convert-wikilinks (content)
  "Convert Obsidian wikilinks in CONTENT to org links."
  (let ((link-map '()))
    ;; First pass: collect all wikilinks and create ID mappings
    (with-temp-buffer
      (insert content)
      (goto-char (point-min))
      (while (re-search-forward "\\[\\[\\([^]|]+\\)\\(?:|\\([^]]+\\)\\)?\\]\\]" nil t)
        (let* ((link (match-string 1))
               (desc (or (match-string 2) link))
               (id (org-id-new)))
          (push (list link desc id) link-map))))

    ;; Second pass: replace wikilinks with org-roam links
    (dolist (link-info link-map)
      (let ((link (nth 0 link-info))
            (desc (nth 1 link-info))
            (id (nth 2 link-info)))
        (setq content (replace-regexp-in-string
                      (regexp-quote (format "[[%s]]" link))
                      (format "[[id:%s][%s]]" id desc)
                      content))
        (setq content (replace-regexp-in-string
                      (regexp-quote (format "[[%s|%s]]" link desc))
                      (format "[[id:%s][%s]]" id desc)
                      content))))
    content))

(defun hp/obsidian-to-org--convert-image-embeds (content base-dir output-dir)
  "Convert Obsidian image embeds in CONTENT to org syntax.
BASE-DIR is the source directory, OUTPUT-DIR is the destination."
  (let ((attachments-copied '()))
    (with-temp-buffer
      (insert content)
      (goto-char (point-min))

      ;; Convert ![[image]] syntax
      (while (re-search-forward "!\\[\\[\\([^]]+\\)\\]\\]" nil t)
        (let* ((image-ref (match-string 1))
               (image-name (file-name-nondirectory image-ref))
               (new-path ""))

          ;; Find the actual image file
          (catch 'found
            (dolist (attach-dir hp/obsidian-attachment-dirs)
              (let ((possible-path (expand-file-name image-ref
                                                   (expand-file-name attach-dir base-dir))))
                (when (file-exists-p possible-path)
                  ;; Copy attachment if not already copied
                  (unless (member possible-path attachments-copied)
                    (let ((dest-dir (expand-file-name "assets" output-dir)))
                      (make-directory dest-dir t)
                      (copy-file possible-path
                               (expand-file-name image-name dest-dir)
                               t)
                      (push possible-path attachments-copied)))
                  (setq new-path (format "[[file:./assets/%s]]" image-name))
                  (throw 'found t)))))

          ;; Replace the image reference
          (when new-path
            (replace-match new-path t t))))

      ;; Convert ![](url) syntax
      (goto-char (point-min))
      (while (re-search-forward "!\\[\\([^]]*\\)\\](\\([^)]+\\))" nil t)
        (let ((alt-text (match-string 1))
              (url (match-string 2)))
          (replace-match (format "[[%s][%s]]" url (or alt-text url)) t t)))

      (buffer-string))))

(defun hp/obsidian-to-org--convert-tags (content)
  "Convert Obsidian #tags in CONTENT to org format."
  ;; Convert standalone tags
  (setq content (replace-regexp-in-string
                "\\(?:^\\|\\s-\\)#\\([a-zA-Z0-9_-]+\\)"
                " :\\1:"
                content))
  content)

(defun hp/obsidian-to-org--process-body-content (body base-dir output-dir)
  "Process BODY content converting markdown syntax to org.
BASE-DIR is the source directory, OUTPUT-DIR is the destination."
  (if (not (stringp body))
      ""  ; Return empty string if body is not a string
    (let ((result body))
      (condition-case err
          (progn
            ;; Convert wikilinks
            (setq result (hp/obsidian-to-org--convert-wikilinks result))
            
            ;; Convert image embeds
            (setq result (hp/obsidian-to-org--convert-image-embeds result base-dir output-dir))
            
            ;; Convert markdown headers to org headers: # Header → * Header
            (setq result (replace-regexp-in-string "^\\(#+\\)\\s-*\\([^+:].+\\)$" 
                                                  (lambda (match)
                                                    (let ((hashes (match-string 1 match))
                                                          (content (match-string 2 match)))
                                                      (concat (make-string (length hashes) ?*) " " content)))
                                                  result))
            
            ;; Convert text formatting
            (setq result (replace-regexp-in-string "\\*\\*\\([^*\n]+\\)\\*\\*" "*\\1*" result))
            (setq result (replace-regexp-in-string "__\\([^_\n]+\\)__" "*\\1*" result))
            (setq result (replace-regexp-in-string "\\b_\\([^_\n]+\\)_\\b" "/\\1/" result))
            (setq result (replace-regexp-in-string "~~\\([^~\n]+\\)~~" "+\\1+" result))
            (setq result (replace-regexp-in-string "==\\([^=\n]+\\)==" "@@html:<mark>@@\\1@@html:</mark>@@" result))
            
            ;; Convert code blocks
            (setq result (replace-regexp-in-string "```\\([a-zA-Z0-9-_+]*\\)\\s-*\n" "#+begin_src \\1\n" result))
            (setq result (replace-regexp-in-string "^```\\s-*$" "#+end_src" result))
            
            ;; Convert inline code
            (setq result (replace-regexp-in-string "`\\([^`\n]+\\)`" "~\\1~" result))
            
            ;; Convert block quotes
            (setq result (replace-regexp-in-string "^> \\(.+\\)$" "#+begin_quote\n\\1\n#+end_quote" result))
            
            ;; Convert single asterisk italic  
            (setq result (replace-regexp-in-string "\\*\\([^*\n]+?\\)\\*" "/\\1/" result))
            
            ;; Convert markdown links
            (setq result (replace-regexp-in-string "\\[\\([^]]+\\)\\](\\([^)]+\\))" "[[\\2][\\1]]" result))
            
            result)
        (error
         (message "Error processing body content: %s" (error-message-string err))
         body)))))

(defun hp/obsidian-to-org-convert-file (file)
  "Convert a single Obsidian FILE to org-mode format."
  (interactive "fSelect Obsidian file to convert: ")
  (let* ((base-dir (file-name-directory file))
         (file-name (file-name-nondirectory file))
         (org-file-name (concat (file-name-sans-extension file-name) ".org"))
         (output-dir hp/obsidian-org-output-dir)
         (output-file (expand-file-name org-file-name output-dir)))
    
    ;; Read file content
    (with-temp-buffer
      (insert-file-contents file)
      (let* ((content (buffer-string))
             ;; Extract data from Obsidian file
             (data (hp/obsidian-to-org--extract-data content))
             (body (plist-get data :body))
             ;; Process body content for markdown->org conversions
             (processed-body (hp/obsidian-to-org--process-body-content 
                             body base-dir output-dir))
             ;; Update data with processed body
             (updated-data (plist-put (copy-sequence data) :body processed-body))
             ;; Rebuild clean org file
             (org-content (hp/obsidian-to-org--rebuild-org-file updated-data file-name)))
        
        ;; Debug logging
        (message "Debug: Original body length: %s" (if body (length body) "nil"))
        (message "Debug: Processed body length: %s" (if processed-body (length processed-body) "nil"))
        (message "Debug: Final org content length: %s" (length org-content))
        
        ;; Create output directory if needed
        (make-directory output-dir t)
        
        ;; Write to new file
        (with-temp-file output-file
          (insert org-content))
        
        ;; Open the converted file
        (find-file output-file)
        (org-mode)
        ;; Force a single database update
        (org-roam-db-update-file)
        
        (message "Converted %s to %s" file-name output-file)))))

(defun hp/obsidian-to-org-convert-buffer ()
  "Convert current Obsidian markdown buffer to org-mode format."
  (interactive)
  (unless (derived-mode-p 'markdown-mode)
    (user-error "Current buffer is not in markdown mode"))

  (let* ((input-file (buffer-file-name))
         (base-dir (file-name-directory input-file))
         (file-name (file-name-nondirectory input-file))
         (org-file-name (concat (file-name-sans-extension file-name) ".org"))
         (output-dir hp/obsidian-org-output-dir)
         (output-file (expand-file-name org-file-name output-dir))
         (content (buffer-string)))

    ;; Create output directory if needed
    (make-directory output-dir t)

    ;; Extract data from Obsidian file
    (let* ((data (hp/obsidian-to-org--extract-data content))
           (body (plist-get data :body))
           ;; Process body content for markdown->org conversions
           (processed-body (hp/obsidian-to-org--process-body-content 
                           body base-dir output-dir))
           ;; Update data with processed body
           (updated-data (plist-put (copy-sequence data) :body processed-body))
           ;; Rebuild clean org file
           (org-content (hp/obsidian-to-org--rebuild-org-file updated-data file-name)))
      
      ;; Write to new file
      (with-temp-file output-file
        (insert org-content))

      ;; Open the converted file
      (find-file output-file)
      (org-mode)
      ;; Force a single database update
      (org-roam-db-update-file)

      (message "Converted %s to %s" file-name output-file))))

(defun hp/obsidian-to-org-convert-directory (directory &optional recursive)
  "Convert all Obsidian markdown files in DIRECTORY to org-mode.
If RECURSIVE is non-nil, process subdirectories as well."
  (interactive "DDirectory: \nP")

  (let* ((md-files (if recursive
                      (directory-files-recursively directory "\\.md$")
                    (directory-files directory t "\\.md$")))
         (total (length md-files))
         (count 0)
         (errors '()))

    (dolist (file md-files)
      (setq count (1+ count))
      (message "Converting %d/%d: %s" count total (file-name-nondirectory file))

      (condition-case err
          (with-temp-buffer
            (insert-file-contents file)
            (let* ((base-dir (file-name-directory file))
                   (rel-path (file-relative-name file directory))
                   (rel-dir (file-name-directory rel-path))
                   (output-dir (if rel-dir
                                 (expand-file-name rel-dir hp/obsidian-org-output-dir)
                               hp/obsidian-org-output-dir))
                   (org-file-name (concat (file-name-sans-extension
                                         (file-name-nondirectory file)) ".org"))
                   (output-file (expand-file-name org-file-name output-dir))
                   (content (buffer-string)))

              ;; Create output directory structure
              (make-directory output-dir t)

              ;; Extract data and rebuild org file
              (let* ((data (hp/obsidian-to-org--extract-data content))
                     (body (plist-get data :body))
                     ;; Process body content for markdown->org conversions
                     (processed-body (hp/obsidian-to-org--process-body-content 
                                     body base-dir output-dir))
                     ;; Update data with processed body
                     (updated-data (plist-put (copy-sequence data) :body processed-body))
                     ;; Rebuild clean org file
                     (org-content (hp/obsidian-to-org--rebuild-org-file 
                                  updated-data (file-name-nondirectory file))))
                (with-temp-file output-file
                  (insert org-content)))))
        (error
         (push (cons file err) errors))))

    ;; Update org-roam database for all new files
    (org-roam-db-sync)

    ;; Report results
    (if errors
        (message "Converted %d files with %d errors. Check *Messages* for details."
                 (- total (length errors)) (length errors))
      (message "Successfully converted %d files." total))

    ;; Log errors
    (dolist (error errors)
      (message "Error converting %s: %s" (car error) (cdr error)))))

(defun hp/obsidian-to-org-convert-directory-recursive (directory)
  "Convert all Obsidian markdown files in DIRECTORY and all subdirectories to org-mode."
  (interactive "DDirectory: ")
  ;; Just call the regular function with recursive flag set to t
  (hp/obsidian-to-org-convert-directory directory t))

(defun hp/obsidian-to-org-generate-indices (directory)
  "Generate index.org files recursively and move single files up to parent directories."
  (interactive "DDirectory: ")
  (let ((moved-files 0)
        (created-indices 0))
    
    ;; First pass: Move single files up to parent directory
    (hp/obsidian-to-org--consolidate-single-files directory)
    
    ;; Second pass: Create index files for all directories with content
    (hp/obsidian-to-org--create-indices-recursive directory)
    
    ;; Update org-roam database
    (org-roam-db-sync)
    
    (message "Reorganized directory structure and created index files")))

(defun hp/obsidian-to-org--consolidate-single-files (directory)
  "Move files from directories containing only one file up to parent directory."
  (let ((all-dirs (seq-filter #'file-directory-p 
                             (directory-files-recursively directory "." t))))
    ;; Process from deepest to shallowest
    (dolist (dir (sort all-dirs (lambda (a b) (> (length a) (length b)))))
      (let* ((files (directory-files dir t "^[^.].*\\.org$"))
             (non-index-files (seq-remove (lambda (f) 
                                           (string= (file-name-nondirectory f) "index.org"))
                                         files)))
        (when (= (length non-index-files) 1)
          ;; Move the single file to parent directory
          (let* ((file (car non-index-files))
                 (parent-dir (file-name-directory (directory-file-name dir)))
                 (new-path (expand-file-name (file-name-nondirectory file) parent-dir)))
            (unless (file-exists-p new-path)
              (rename-file file new-path)
              (message "Moved %s to %s" (file-name-nondirectory file) parent-dir))
            ;; Remove empty directory
            (when (= (length (directory-files dir t "^[^.]")) 0)
              (delete-directory dir))))))))

(defun hp/obsidian-to-org--create-indices-recursive (directory &optional parent-level)
  "Create index.org files recursively for DIRECTORY and all subdirectories."
  (let ((level (or parent-level 0)))
    ;; Get all files and subdirectories in current directory
    (let* ((all-files (directory-files directory t "^[^.]"))
           (org-files (seq-filter (lambda (f) 
                                   (and (string-match-p "\\.org$" f)
                                        (not (string= (file-name-nondirectory f) "index.org"))))
                                 all-files))
           (subdirs (seq-filter #'file-directory-p all-files)))
      
      ;; Only create index if there are org files or subdirectories
      (when (or org-files subdirs)
        (let ((index-file (expand-file-name "index.org" directory))
              (dir-name (file-name-nondirectory (directory-file-name directory))))
          
          (with-temp-file index-file
            ;; Add org-roam properties
            (insert ":PROPERTIES:\n")
            (insert (format ":ID:       %s\n" (org-id-new)))
            (insert ":END:\n")
            (insert (format "#+title: %s\n\n" (capitalize (replace-regexp-in-string "-" " " dir-name))))
            
            ;; Add ID links to files in current directory
            (dolist (file (sort org-files #'string<))
              (let ((id nil)
                    (title (file-name-sans-extension (file-name-nondirectory file))))
                ;; Extract ID and title from the file
                (when (file-exists-p file)
                  (with-temp-buffer
                    (insert-file-contents file nil 0 1000) ; Read more to ensure we get the ID
                    ;; Extract ID
                    (goto-char (point-min))
                    (when (re-search-forward "^:ID:\\s-+\\([a-zA-Z0-9-]+\\)" nil t)
                      (setq id (match-string 1)))
                    ;; Extract title
                    (goto-char (point-min))
                    (when (re-search-forward "^#\\+title:\\s-*\\(.+\\)$" nil t)
                      (setq title (match-string 1)))))
                ;; Write the ID link
                (when id
                  (insert (format "[[id:%s][%s]]\n" id title)))))
            
            ;; Add links to subdirectory indices
            (when subdirs
              (insert "\n")
              (dolist (subdir (sort subdirs #'string<))
                (let ((subdir-index (expand-file-name "index.org" subdir))
                      (subdir-name (file-name-nondirectory (directory-file-name subdir))))
                  ;; Check if subdirectory will have an index
                  (when (or (directory-files subdir nil "\\.org$")
                           (seq-filter #'file-directory-p 
                                      (directory-files subdir t "^[^.]")))
                    ;; Extract ID from the subdirectory index if it exists
                    (let ((subdir-id nil)
                          (subdir-title (capitalize (replace-regexp-in-string "-" " " subdir-name))))
                      (when (file-exists-p subdir-index)
                        (with-temp-buffer
                          (insert-file-contents subdir-index nil 0 500)
                          (when (re-search-forward "^:ID:\\s-+\\([a-zA-Z0-9-]+\\)" nil t)
                            (setq subdir-id (match-string 1)))))
                      ;; If no ID yet, we'll need to process subdirs first
                      (unless subdir-id
                        ;; Process subdir first to create its index
                        (hp/obsidian-to-org--create-indices-recursive subdir (1+ level))
                        ;; Now try to get the ID again
                        (when (file-exists-p subdir-index)
                          (with-temp-buffer
                            (insert-file-contents subdir-index nil 0 500)
                            (when (re-search-forward "^:ID:\\s-+\\([a-zA-Z0-9-]+\\)" nil t)
                              (setq subdir-id (match-string 1))))))
                      (when subdir-id
                        (insert (format "[[id:%s][%s]]\n" subdir-id subdir-title)))))))))
          
          (message "Created index for %s (level %d)" dir-name level)))
      
      ;; Process remaining subdirectories
      (dolist (subdir subdirs)
        (unless (file-exists-p (expand-file-name "index.org" subdir))
          (hp/obsidian-to-org--create-indices-recursive subdir (1+ level)))))))

(defun hp/obsidian-to-org-convert-and-index (directory)
  "Convert all Obsidian files in DIRECTORY recursively and generate index.org files."
  (interactive "DDirectory: ")
  ;; First convert all markdown files
  (hp/obsidian-to-org-convert-directory-recursive directory)
  ;; Then generate indices
  (hp/obsidian-to-org-generate-indices hp/obsidian-org-output-dir))

(defun hp/org-rename-to-zettelkasten (directory)
  "Rename all org files in DIRECTORY to Zettelkasten format YYYYMMDDHHMMSS-title.org."
  (interactive "DDirectory: ")
  (let ((renamed-count 0)
        (skipped-count 0)
        (error-count 0))
    ;; Get all org files recursively
    (dolist (file (directory-files-recursively directory "\\.org$"))
      (let ((filename (file-name-nondirectory file)))
        ;; Check if file already follows Zettelkasten format
        (unless (or (string-match "^[0-9]\\{14\\}-.*\\.org$" filename)
                    (string= filename "index.org"))
          (condition-case err
              (let ((title nil)
                    (created-date nil))
                ;; Extract title and created date from file
                (with-temp-buffer
                  (insert-file-contents file nil 0 1000)
                  ;; Extract title
                  (goto-char (point-min))
                  (when (re-search-forward "^#\\+title:\\s-*\\(.+\\)$" nil t)
                    (setq title (match-string 1)))
                  ;; Extract created date if available
                  (goto-char (point-min))
                  (when (re-search-forward "^#\\+created:\\s-*\\[\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\)" nil t)
                    (setq created-date (match-string 1))))
                
                (if title
                    (let* (;; Generate timestamp
                           (timestamp (if created-date
                                         ;; Use created date if available
                                         (format-time-string "%Y%m%d%H%M%S" 
                                                           (date-to-time (concat created-date " 00:00:00")))
                                       ;; Otherwise use file modification time
                                       (format-time-string "%Y%m%d%H%M%S" 
                                                         (nth 5 (file-attributes file)))))
                           ;; Clean title for filename
                           (clean-title (hp/org-sanitize-title-for-filename title))
                           ;; Create new filename
                           (new-filename (format "%s-%s.org" timestamp clean-title))
                           (new-filepath (expand-file-name new-filename 
                                                          (file-name-directory file))))
                      
                      ;; Check if new filename already exists
                      (if (file-exists-p new-filepath)
                          (progn
                            (message "Skipped %s: Target file already exists" filename)
                            (setq skipped-count (1+ skipped-count)))
                        ;; Rename the file
                        (rename-file file new-filepath)
                        (message "Renamed: %s -> %s" filename new-filename)
                        (setq renamed-count (1+ renamed-count))))
                  ;; No title found
                  (message "Skipped %s: No title found" filename)
                  (setq skipped-count (1+ skipped-count))))
            (error
             (message "Error renaming %s: %s" filename (error-message-string err))
             (setq error-count (1+ error-count)))))))
    
    ;; Report results
    (message "Zettelkasten rename complete: %d renamed, %d skipped, %d errors" 
             renamed-count skipped-count error-count)
    
    ;; Update org-roam database if files were renamed
    (when (> renamed-count 0)
      (org-roam-db-sync))))

(defun hp/org-sanitize-title-for-filename (title)
  "Sanitize TITLE to be safe for use in filename."
  (let ((safe-title title))
    ;; Remove or replace problematic characters
    (setq safe-title (replace-regexp-in-string "[/\\:*?\"<>|]" "-" safe-title))
    ;; Replace multiple spaces with single dash
    (setq safe-title (replace-regexp-in-string "\\s-+" "-" safe-title))
    ;; Remove leading/trailing dashes and spaces
    (setq safe-title (replace-regexp-in-string "^[-\\s]+\\|[-\\s]+$" "" safe-title))
    ;; Convert to lowercase
    (setq safe-title (downcase safe-title))
    ;; Limit length to avoid filesystem issues
    (if (> (length safe-title) 100)
        (substring safe-title 0 100)
      safe-title)))

(defun hp/org-extract-tags-from-title (title)
  "Extract tags from TITLE string and return (clean-title . tags-list).
For example, 'DoomAI :tool:doomai:ai:' returns ('DoomAI' . '(tool doomai ai)')"
  (if (string-match "^\\([^:]+\\)\\(\\s-*:\\(?:[^:]+:\\)+\\)\\s-*$" title)
      (let ((clean-title (match-string 1 title))
            (tags-part (match-string 2 title)))
        ;; Extract individual tags from :tag1:tag2:tag3:
        (let ((tags '()))
          (string-match ":\\(.*\\):" tags-part)
          (when (match-string 1 tags-part)
            (setq tags (split-string (match-string 1 tags-part) ":" t)))
          (cons (string-trim clean-title) tags)))
    ;; No tags found, return title as-is
    (cons (string-trim title) nil)))

(defun hp/zettelkasten-timestamp-to-org-date (timestamp)
  "Convert Zettelkasten TIMESTAMP (YYYYMMDDHHmmss) to org date format.
For example, '20250803183700' returns '[2025-08-03 Sun 18:37]'"
  (when (string-match "^\\([0-9]\\{4\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)" timestamp)
    (let* ((year (match-string 1 timestamp))
           (month (match-string 2 timestamp))
           (day (match-string 3 timestamp))
           (hour (match-string 4 timestamp))
           (minute (match-string 5 timestamp))
           (date-string (format "%s-%s-%s %s:%s" year month day hour minute))
           (time (date-to-time date-string))
           (day-name (format-time-string "%a" time)))
      (format "[%s-%s-%s %s %s:%s]" year month day day-name hour minute))))

(defun hp/org-rename-single-file-to-zettelkasten (file)
  "Process and optionally rename a single FILE to Zettelkasten format.
If the file is already in Zettelkasten format, it will update the file content:
- Clean title by removing tags
- Add #+created: from filename timestamp
- Move tags to #+filetags:
- Add #+startup: overview if missing"
  (interactive "fSelect file to process: ")
  (let ((filename (file-name-nondirectory file)))
    (condition-case err
        (if (string-match "^\\([0-9]\\{14\\}\\)-.*\\.org$" filename)
            ;; File is already in Zettelkasten format - update its content
            (let* ((timestamp (match-string 1 filename))
                   (org-date (hp/zettelkasten-timestamp-to-org-date timestamp))
                   (file-content (with-temp-buffer
                                 (insert-file-contents file)
                                 (buffer-string)))
                   (lines (split-string file-content "\n"))
                   (title nil)
                   (clean-title nil)
                   (tags nil)
                   (has-created nil)
                   (has-filetags nil)
                   (has-startup nil)
                   (new-lines '()))
              
              ;; Process each line
              (dolist (line lines)
                (cond
                 ;; Process title line
                 ((string-match "^#\\+title:\\s-*\\(.+\\)$" line)
                  (setq title (match-string 1 line))
                  (let ((title-parts (hp/org-extract-tags-from-title title)))
                    (setq clean-title (car title-parts))
                    (setq tags (cdr title-parts))
                    (push (format "#+title: %s" clean-title) new-lines)))
                 
                 ;; Check for existing metadata
                 ((string-match "^#\\+created:" line)
                  (setq has-created t)
                  (push line new-lines))
                 
                 ((string-match "^#\\+filetags:" line)
                  (setq has-filetags t)
                  ;; If we have tags from title, update filetags
                  (if tags
                      (push (format "#+filetags: %s" (mapconcat 'identity tags " ")) new-lines)
                    (push line new-lines)))
                 
                 ((string-match "^#\\+startup:" line)
                  (setq has-startup t)
                  (push line new-lines))
                 
                 ;; Keep other lines as-is
                 (t (push line new-lines))))
              
              ;; Add missing metadata after title
              (setq new-lines (nreverse new-lines))
              (let ((title-pos (cl-position-if (lambda (line) (string-match "^#\\+title:" line)) new-lines)))
                (when title-pos
                  (let ((insert-pos (1+ title-pos))
                        (insertions '()))
                    
                    ;; Add missing metadata in reverse order (they'll be reversed when inserted)
                    (unless has-startup
                      (push "#+startup: overview" insertions))
                    
                    (unless has-filetags
                      (when tags
                        (push (format "#+filetags: %s" (mapconcat 'identity tags " ")) insertions)))
                    
                    (unless has-created
                      (when org-date
                        (push (format "#+created: %s" org-date) insertions)))
                    
                    ;; Insert the metadata
                    (dolist (insertion insertions)
                      (setq new-lines (append (cl-subseq new-lines 0 insert-pos)
                                            (list insertion)
                                            (cl-subseq new-lines insert-pos)))))))
              
              ;; Write the updated content back to file
              (with-temp-file file
                (insert (mapconcat 'identity new-lines "\n")))
              
              (message "Updated metadata in: %s" filename)
              
              ;; If file is open, revert it
              (let ((buf (get-file-buffer file)))
                (when buf
                  (with-current-buffer buf
                    (revert-buffer t t))))
              
              ;; Update org-roam database
              (org-roam-db-update-file))
          
          ;; File is not in Zettelkasten format - rename it
          (let ((title nil)
                (created-date nil))
            ;; Extract title and created date from file
            (with-temp-buffer
              (insert-file-contents file nil 0 1000)
              ;; Extract title
              (goto-char (point-min))
              (when (re-search-forward "^#\\+title:\\s-*\\(.+\\)$" nil t)
                (setq title (match-string 1)))
              ;; Extract created date if available
              (goto-char (point-min))
              (when (re-search-forward "^#\\+created:\\s-*\\[\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\)" nil t)
                (setq created-date (match-string 1))))
            
            (if title
                (let* ((title-parts (hp/org-extract-tags-from-title title))
                       (clean-title (car title-parts))
                       (timestamp (if created-date
                                    (format-time-string "%Y%m%d%H%M%S" 
                                                      (date-to-time (concat created-date " 00:00:00")))
                                  (format-time-string "%Y%m%d%H%M%S" 
                                                    (nth 5 (file-attributes file)))))
                       (sanitized-title (hp/org-sanitize-title-for-filename clean-title))
                       (new-filename (format "%s-%s.org" timestamp sanitized-title))
                       (new-filepath (expand-file-name new-filename 
                                                     (file-name-directory file))))
                  
                  (if (file-exists-p new-filepath)
                      (message "Cannot rename: Target file already exists - %s" new-filename)
                    (rename-file file new-filepath)
                    (message "Renamed: %s -> %s" filename new-filename)
                    ;; Process the renamed file to update its content
                    (hp/org-rename-single-file-to-zettelkasten new-filepath)))
              (message "Cannot rename: No title found in %s" filename))))
      (error
       (message "Error processing %s: %s" filename (error-message-string err))))))

(defun hp/org-process-zettelkasten-directory (directory)
  "Process all org files in DIRECTORY recursively to update metadata.
For files already in Zettelkasten format, updates their content:
- Cleans titles by removing tags
- Adds #+created: from filename timestamp
- Moves tags to #+filetags:
- Adds #+startup: overview if missing
For files not in Zettelkasten format, renames them first."
  (interactive "DDirectory: ")
  (let ((processed-count 0)
        (error-count 0))
    ;; Get all org files recursively
    (dolist (file (directory-files-recursively directory "\\.org$"))
      (unless (string= (file-name-nondirectory file) "index.org")
        (condition-case err
            (progn
              (message "Processing: %s" file)
              (hp/org-rename-single-file-to-zettelkasten file)
              (setq processed-count (1+ processed-count)))
          (error
           (message "Error processing %s: %s" file (error-message-string err))
           (setq error-count (1+ error-count))))))
    
    ;; Summary
    (message "Processing complete: %d files processed, %d errors" 
             processed-count error-count)
    
    ;; Update org-roam database if files were processed
    (when (> processed-count 0)
      (org-roam-db-sync))))

(defun hp/obsidian-to-org--copy-attachments (source-dir dest-dir)
  "Copy attachment directories from SOURCE-DIR to DEST-DIR."
  (dolist (attach-dir hp/obsidian-attachment-dirs)
    (let ((src (expand-file-name attach-dir source-dir))
          (dst (expand-file-name attach-dir dest-dir)))
      (when (file-directory-p src)
        (make-directory (file-name-directory dst) t)
        (copy-directory src dst t t t)))))

(defvar hp/obsidian-to-org-sync-timer nil
  "Timer for automatic Obsidian to Org synchronization.")

(defun hp/obsidian-to-org-auto-sync ()
  "Set up automatic synchronization of Obsidian vault to org-roam."
  (interactive)

  (when hp/obsidian-to-org-sync-timer
    (cancel-timer hp/obsidian-to-org-sync-timer))

  (setq hp/obsidian-to-org-sync-timer
        (run-with-timer
         300 ; 5 minutes initial delay
         1800 ; 30 minutes repeat
         (lambda ()
           (message "Starting Obsidian to Org sync...")
           (hp/obsidian-to-org-convert-directory
            obsidian-directory t)
           (message "Obsidian to Org sync completed."))))

  (message "Automatic Obsidian to Org sync enabled (every 30 minutes)"))

(defun hp/obsidian-to-org-stop-auto-sync ()
  "Stop automatic synchronization of Obsidian vault."
  (interactive)
  (when hp/obsidian-to-org-sync-timer
    (cancel-timer hp/obsidian-to-org-sync-timer)
    (setq hp/obsidian-to-org-sync-timer nil)
    (message "Automatic Obsidian to Org sync disabled")))

;; Add keybindings for conversion functions
(map! :leader
      :prefix "n"
      (:prefix ("i" . "import")
       (:prefix ("o" . "obsidian")
        :desc "Import current buffer" "b" #'hp/obsidian-to-org-convert-buffer
        :desc "Import single file" "f" #'hp/obsidian-to-org-convert-file
        :desc "Import directory" "d" #'hp/obsidian-to-org-convert-directory
        :desc "Import directory (recursive)" "D" #'hp/obsidian-to-org-convert-directory-recursive
        :desc "Generate index files" "i" #'hp/obsidian-to-org-generate-indices
        :desc "Convert & index (recursive)" "I" #'hp/obsidian-to-org-convert-and-index
        :desc "Rename to Zettelkasten (directory)" "z" #'hp/org-rename-to-zettelkasten
        :desc "Rename to Zettelkasten (file)" "Z" #'hp/org-rename-single-file-to-zettelkasten
        :desc "Process Zettelkasten directory (update metadata)" "p" #'hp/org-process-zettelkasten-directory
        :desc "Start auto sync" "s" #'hp/obsidian-to-org-auto-sync
        :desc "Stop auto sync" "S" #'hp/obsidian-to-org-stop-auto-sync)))
#+end_src

(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam
  :commands (org-roam-ui-mode))
#+end_src

***** Workspace creation
This is to automate creating a workspace for Org-roam

#+begin_src emacs-lisp
(after! (org-roam)
  (defadvice! yeet/org-roam-in-own-workspace-a (&rest _)
  "Open all roam buffers in there own workspace."
  :before #'org-roam-node-find
  :before #'org-roam-node-random
  :before #'org-roam-buffer-display-dedicated
  :before #'org-roam-buffer-toggle
  :before #'org-roam-dailies-goto-today
  (when (modulep! :ui workspaces)
    (+workspace-switch "Org-roam" t))))
#+end_src

***** Org-roam-protocol

#+begin_src emacs-lisp
(use-package! org-roam-protocol
  :after (org-roam org-roam-dailies org-protocol)
  :config
  (add-to-list
   'org-roam-capture-ref-templates
   `(;; Browser bookletmark template:
     ;; javascript:location.href =
     ;; 'org-protocol://roam-ref?template=w&ref='
     ;; + encodeURIComponent(location.href)
     ;; + '&title='
     ;; + encodeURIComponent(document.getElementsByTagName("h1")[0].innerText)
     ;; + '&hostname='
     ;; + encodeURIComponent(location.hostname)
     ("w" "webref" entry "* ${title} ([[${ref}][${hostname}]])\n%?"
      :target
      (file+head
       ,(concat org-roam-dailies-directory "%<%Y-%m>.org")
       ,(string-join
         '(":properties:"
           ":roam_refs: %^{Key}"
           ":end:"
           "#+title: %<%Y-%m>"
           "#+filetags: journal"
           "#+startup: overview"
           "#+created: %U"
           "") "\n"))
      :unnarrowed t))))
#+end_src

**** Org-roam and Org-agenda itegration
Integrating Org-roam and Org-agenda might be complicated, since Org-roam pushes us towards making many =.org= files, and Org-agenda works best with a few, big =.org= files.

The solution proposed in [[https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html][this blog post]] is to dynamically update the variable =org-agenda-files=, so that Org-agenda only check for Org-roam files that contains certain tags.
In my case, the tags that are marked for inspection are =tasked= and =schedule=.
Org-roam files are automatically marked with =tasked= as long as it has any =TODO= heading.
Files with =schedule= tags are designated manually.

#+begin_src emacs-lisp
(after! (org-agenda org-roam)
  (defun vulpea-task-p ()
    "Return non-nil if current buffer has any todo entry.

TODO entries marked as done are ignored, meaning the this
function returns nil if current buffer contains only completed
tasks."
    (seq-find                                 ; (3)
     (lambda (type)
       (eq type 'todo))
     (org-element-map                         ; (2)
         (org-element-parse-buffer 'headline) ; (1)
         'headline
       (lambda (h)
         (org-element-property :todo-type h)))))

  (defun vulpea-task-update-tag ()
    "Update task tag in the current buffer."
    (when (and (not (active-minibuffer-window))
               (vulpea-buffer-p))
      (save-excursion
        (goto-char (point-min))
        (let* ((tags (vulpea-buffer-tags-get))
               (original-tags tags))
          (if (vulpea-task-p)
              (setq tags (cons "task" tags))
            (setq tags (remove "task" tags)))

          ;; cleanup duplicates
          (setq tags (seq-uniq tags))

          ;; update tags if changed
          (when (or (seq-difference tags original-tags)
                    (seq-difference original-tags tags))
            (apply #'vulpea-buffer-tags-set tags))))))

  (defun vulpea-buffer-p ()
    "Return non-nil if the currently visited buffer is a note."
    (and buffer-file-name
         (string-prefix-p
          (expand-file-name (file-name-as-directory org-roam-directory))
          (file-name-directory buffer-file-name))))

  (defun vulpea-task-files ()
    "Return a list of note files containing 'task' tag." ;
    (seq-uniq
     (seq-map
      #'car
      (org-roam-db-query
       [:select [nodes:file]
        :from tags
        :left-join nodes
        :on (= tags:node-id nodes:id)
        :where (or (like tag (quote "%\"task\"%"))
                   (like tag (quote "%\"schedule\"%")))]))))

  (defun vulpea-agenda-files-update (&rest _)
    "Update the value of `org-agenda-files'."
    (setq org-agenda-files (vulpea-task-files)))

  (add-hook 'find-file-hook #'vulpea-task-update-tag)
  (add-hook 'before-save-hook #'vulpea-task-update-tag)

  (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
  (advice-add 'org-todo-list :before #'vulpea-agenda-files-update)

  ;; functions borrowed from `vulpea' library
  ;; https://github.com/d12frosted/vulpea/blob/6a735c34f1f64e1f70da77989e9ce8da7864e5ff/vulpea-buffer.el

  (defun vulpea-buffer-tags-get ()
    "Return filetags value in current buffer."
    (vulpea-buffer-prop-get-list "filetags" "[ :]"))

  (defun vulpea-buffer-tags-set (&rest tags)
    "Set TAGS in current buffer.

If filetags value is already set, replace it."
    (if tags
        (vulpea-buffer-prop-set
         "filetags" (concat ":" (string-join tags ":") ":"))
      (vulpea-buffer-prop-remove "filetags")))

  (defun vulpea-buffer-tags-add (tag)
    "Add a TAG to filetags in current buffer."
    (let* ((tags (vulpea-buffer-tags-get))
           (tags (append tags (list tag))))
      (apply #'vulpea-buffer-tags-set tags)))

  (defun vulpea-buffer-tags-remove (tag)
    "Remove a TAG from filetags in current buffer."
    (let* ((tags (vulpea-buffer-tags-get))
           (tags (delete tag tags)))
      (apply #'vulpea-buffer-tags-set tags)))

  (defun vulpea-buffer-prop-set (name value)
    "Set a file property called NAME to VALUE in buffer file.
If the property is already set, replace its value."
    (setq name (downcase name))
    (org-with-point-at 1
      (let ((case-fold-search t))
        (if (re-search-forward (concat "^#\\+" name ":\\(.*\\)")
                               (point-max) t)
            (replace-match (concat "#+" name ": " value) 'fixedcase)
          (while (and (not (eobp))
                      (looking-at "^[#:]"))
            (if (save-excursion (end-of-line) (eobp))
                (progn
                  (end-of-line)
                  (insert "\n"))
              (forward-line)
              (beginning-of-line)))
          (insert "#+" name ": " value "\n")))))

  (defun vulpea-buffer-prop-set-list (name values &optional separators)
    "Set a file property called NAME to VALUES in current buffer.
VALUES are quoted and combined into single string using
`combine-and-quote-strings'.
If SEPARATORS is non-nil, it should be a regular expression
matching text that separates, but is not part of, the substrings.
If nil it defaults to `split-string-default-separators', normally
\"[ \f\t\n\r\v]+\", and OMIT-NULLS is forced to t.
If the property is already set, replace its value."
    (vulpea-buffer-prop-set
     name (combine-and-quote-strings values separators)))

  (defun vulpea-buffer-prop-get (name)
    "Get a buffer property called NAME as a string."
    (org-with-point-at 1
      (when (re-search-forward (concat "^#\\+" name ": \\(.*\\)")
                               (point-max) t)
        (buffer-substring-no-properties
         (match-beginning 1)
         (match-end 1)))))

  (defun vulpea-buffer-prop-get-list (name &optional separators)
    "Get a buffer property NAME as a list using SEPARATORS.
If SEPARATORS is non-nil, it should be a regular expression
matching text that separates, but is not part of, the substrings.
If nil it defaults to `split-string-default-separators', normally
\"[ \f\t\n\r\v]+\", and OMIT-NULLS is forced to t."
    (let ((value (vulpea-buffer-prop-get name)))
      (when (and value (not (string-empty-p value)))
        (split-string-and-unquote value separators))))

  (defun vulpea-buffer-prop-remove (name)
    "Remove a buffer property called NAME."
    (org-with-point-at 1
      (when (re-search-forward (concat "\\(^#\\+" name ":.*\n?\\)")
                               (point-max) t)
        (replace-match ""))))
  )
#+end_src

**** Org-roam and citar integration
Citar integrates with Org-roam via =citar-org-roam.el=.
This makes the comand =citar-open-notes=  (bind to ~SPC n b~) use Org-roam's template system.
The bibliography notes created this way will be set up with proper =ID= and =ROAM_REFS= properties.
The integration also comes with a nice inteface when following an org citation

#+caption: Following a citation in Org-mode, with Citar and Org-roam integraion
[[file:pics/citar-org-roam-follow.png]]

Here's the relevent part:

#+begin_src emacs-lisp
(use-package citar-org-roam
  :after citar org-roam
  :no-require
  :config
  (setq citar-org-roam-subdir "literature"
        citar-org-roam-note-title-template
        (string-join
         '("${author editor} (${year issued date}) ${title}"
           "#+filetags: literature"
           "#+startup: overview"
           "#+options: toc:2 num:t"
           "#+hugo_base_dir: ~/Dropbox/Blogs/hieutkt/"
           "#+hugo_section: ./notes"
           "#+hugo_custom_front_matter: :exclude true :math true"
           "#+hugo_custom_front_matter: :bibinfo '((doi .\"${doi}\") (isbn . \"${isbn}\") (url . \"${url}\") (year . \"${year}\") (month . \"${month}\") (date . \"${date}\") (author . \"${author}\") (journal . \"${journal}\"))"
           "#+hugo_series: \"Reading notes\""
           "#+hugo_tags:"
           ""
           "* What?"
           "* Why?"
           "* How?"
           "* And?"
           ) "\n"))
  (citar-org-roam-mode))
#+end_src
**** Backlinks count display

#+begin_src emacs-lisp
(defface hp/org-roam-count-overlay-face
  '((t :inherit org-list-dt :height 0.8))
  "Face for Org Roam count overlay.")

(defun hp/org-roam--count-overlay-make (pos count)
  (let* ((overlay-value (propertize
                         (concat "·" (format "%d" count) " ")
                         'face 'hp/org-roam-count-overlay-face 'display '(raise 0.2)))
         (ov (make-overlay pos pos (current-buffer) nil t)))
    (overlay-put ov 'roam-backlinks-count count)
    (overlay-put ov 'priority 1)
    (overlay-put ov 'after-string overlay-value)))

(defun hp/org-roam--count-overlay-remove-all ()
  (dolist (ov (overlays-in (point-min) (point-max)))
    (when (overlay-get ov 'roam-backlinks-count)
      (delete-overlay ov))))

(defun hp/org-roam--count-overlay-make-all ()
  (hp/org-roam--count-overlay-remove-all)
  (org-element-map (org-element-parse-buffer) 'link
    (lambda (elem)
      (when (string-equal (org-element-property :type elem) "id")
        (let* ((id (org-element-property :path elem))
               (count (caar
                       (org-roam-db-query
                        [:select (funcall count source)
                         :from links
                         :where (= dest $s1)
                         :and (= type "id")]
                        id))))
          (when (< 0 count)
            (hp/org-roam--count-overlay-make
             (org-element-property :end elem)
             count)))))))

(define-minor-mode hp/org-roam-count-overlay-mode
  "Display backlink count for org-roam links."
  :after-hook
  (if hp/org-roam-count-overlay-mode
      (progn
        (hp/org-roam--count-overlay-make-all)
        (add-hook 'after-save-hook #'hp/org-roam--count-overlay-make-all nil t))
    (hp/org-roam--count-overlay-remove-all)
    (remove-hook 'after-save-hook #'hp/org-roam--count-overlay-remove-all t)))

(add-hook 'org-mode-hook #'hp/org-roam-count-overlay-mode)
#+end_src
**** Carrying todos forwards
=org-roam-daily.el= provides a nice interface for daily journaling/note-taking in Emacs.
However, I want to make two related improvements.

The first is that, due to habitual behavior, I've ended up with an excessive number of empty journal files.
We write a handy command to automatically search for empty Org-files in a folder and delete them.

#+begin_src emacs-lisp
(defun hp/delete-empty-org-files (directory)
  "Delete Org files in DIRECTORY that contain only drawers or keywords.
This function is meant to clean out empty org-roam-dailies files."
  (interactive "DDirectory: ")
  (let ((files (directory-files-recursively directory "\\.org$")))
    (dolist (file files)
      (with-temp-buffer
        (insert-file-contents file)
        (goto-char (point-min))
        ;; Check if the file contains only drawers and keywords
        (if (not (re-search-forward "^[^#+:].+$" nil t))
            (delete-file file))))))
#+end_src

The second problem is something I want from Org-journal: =org-journal-carryover-items= which moves all TODO headings from a previous journal entry to today's.
We are going to implement that by advising =org-roam-dailies-goto-today=.

#+begin_src emacs-lisp
(defun hp/org-roam-get-previous-dailies-file ()
  "Get the file name for the most recent previous day's Org-roam dailies file."
  (let ((files (org-roam-dailies--list-files))
        (today (format-time-string "%Y-%m-%d")))
    (cond ((> (length files) 1)
           ;; Get the last and second-last files
           (let ((last-file (nth (- (length files) 1) files))
                 (second-last-file (nth (- (length files) 2) files)))
             ;; Check if the last file is for today
             (if (string-suffix-p (concat today ".org") last-file)
                 second-last-file
               last-file)))
          (t nil)))) ; Return nil if there's only one file (or none).


(defun hp/org-roam-migrate-todos (&rest _)
  "Migrate TODOs from the previous day's Org-roam file to today's file."
  (interactive)
  (let ((yesterday-file (hp/org-roam-get-previous-dailies-file))
        (today-file (buffer-file-name))
        (todo-regexp (concat "^\\*+ " (regexp-opt org-not-done-keywords))))
    (when (and yesterday-file (file-exists-p yesterday-file))
      (with-current-buffer (find-file-noselect yesterday-file)
        (goto-char (point-min))
        (while (re-search-forward todo-regexp nil t)
          (let ((element (org-element-at-point)))
            (when (eq (car element) 'headline)
              (let ((tree (buffer-substring (org-element-property :begin element)
                                            (org-element-property :end element))))
                (with-current-buffer (find-file-noselect today-file)
                  (goto-char (point-max))
                  (insert "\n" tree)
                  (save-buffer))
                ;; After inserting, delete the tree from the original file
                (delete-region (org-element-property :begin element)
                               (org-element-property :end element)))))
        (save-buffer)
        ;; Delete the empty file if needed
        (hp/delete-empty-org-files (file-name-directory yesterday-file))
        (message " Found TODO(s) from the last journal entry... carried them over!"))))
    (save-buffer)))
#+end_src

After carrying all todos forwards, this advise delete the previous journal entry if they ended up in an empty state.

#+begin_src emacs-lisp :tangle no
(advice-add 'org-roam-dailies-goto-today :after #'hp/org-roam-migrate-todos)
#+end_src

**** Handy command for journaling
The following comand create a new heading and add current time to it.

#+begin_src emacs-lisp
(defun hp/org-insert-timestamped-bullet ()
  "Insert a new bullet in Org-mode with the current timestamp."
  (interactive)
  (+org/insert-item-below 1)
  (insert (format-time-string "%H:%M ")))

;; Bind the function to a key combination, for example C-c t
(define-key org-mode-map (kbd "C-c t") 'hp/org-insert-timestamped-bullet)
#+end_src

#+RESULTS:
: hp/org-insert-timestamped-bullet
**** Org-Roam UI
#+begin_src emacs-lisp
(map! :leader
  :prefix "n"
    (:prefix ("r" . "roam")
      :desc "Open Org-Roam UI"      "u" #'org-roam-ui-open))
#+end_src
*** Org-download

#+begin_src emacs-lisp
(use-package! org-download
  :config
  (add-hook 'dired-mode-hook 'org-download-enable)
  ;; Change how inline images are displayed
  (setq org-download-display-inline-images nil))
#+end_src

** R
First programming language that I learnt.
Most of the time, the interation provided by ESS-mode is excellent and I can be productive with it.
Syntax-highlighting in =ess-r-mode= is not so spectacular, however.
Hopefully this will get better once =tree-sitter= is better integrated into Emacs.

#+begin_src emacs-lisp
(use-package! ess
  :config
  (set-popup-rules!
    '(("^\\*R:*\\*$" :side right :size 0.5 :ttl nil)))
  (setq ess-R-font-lock-keywords
        '((ess-R-fl-keyword:keywords . t)
          (ess-R-fl-keyword:constants . t)
          (ess-R-fl-keyword:modifiers . t)
          (ess-R-fl-keyword:fun-defs . t)
          (ess-R-fl-keyword:assign-ops . t)
          (ess-R-fl-keyword:%op% . t)
          (ess-fl-keyword:fun-calls . t)
          (ess-fl-keyword:numbers . t)
          (ess-fl-keyword:operators . t)
          (ess-fl-keyword:delimiters . t)
          (ess-fl-keyword:= . t)
          (ess-R-fl-keyword:F&T . t)))
  (map! (:map (ess-mode-map inferior-ess-mode-map)
         :g ";" #'ess-insert-assign)))
#+end_src

** Stata
Even though I try to use Stata as little as I can, sometimes it's unavoidable, especially in collaboration with applied economists.
I usually use the [[https://github.com/kylebarron/stata_kernel][Jupyter Stata kernel]] in these situations and it's decent, but sometimes I really miss the excellent editing environment that I have in Emacs.
In preparation, here's the little configurations if I ever decide to use Stata in Emacs:

#+begin_src emacs-lisp
(use-package! ess-stata-mode
  :after ess
  :config
  (setq inferior-STA-start-args ""
        inferior-STA-program (executable-find "stata")
        inferior-STA-program-name (executable-find "stata"))
  (add-to-list 'org-src-lang-modes '("jupyter-stata" . stata)))
#+end_src

** Python
Python is widely used and thus is extensively supported everywhere.
While I prefer Julia for numerical computing and R for econometrics and data visualization, Python is good in pretty much everything else.
I am happy with most the defaults given in Doom Emacs, so my custom configuration in this section is only minimal.

#+begin_src emacs-lisp
(use-package! python
  :config
  (set-popup-rules!
    '(("^\\*Python:*\\*$" :side right :size 0.5 :ttl nil))))
#+end_src

** Julia
=lsp-julia= tries to do the smart thing of auto-detecting the project environment as well as the correct path to the =LanguageServer.jl=.
I want it to do the dumb-but-simple thing of using the global installation of =LanguageServer.jl=.

#+begin_src emacs-lisp
(after! lsp-julia
  (setq lsp-julia-flags '("--startup-file=no" "--history-file=no")))
#+end_src

The rest of the configurations is straight forward.

#+begin_src emacs-lisp
(after! julia-mode
  (add-hook 'julia-mode-hook #'rainbow-delimiters-mode-enable))

(use-package! ob-julia
  :config
  (setq org-babel-julia-backend 'julia-snail))
#+end_src

Julia-snail is good.

#+begin_src emacs-lisp
(after! julia-snail
  (map! :map julia-snail-mode-map
        :g "C-c C-z" #'julia-snail
        :g "C-c C-l" #'julia-snail-send-line
        :map julia-repl-mode-map
        "C-c C-a" nil ;julia-snail-package-activate
        "C-c C-z" nil ;julia-snail
        "C-c C-c" nil ;julia-snail-send-top-level-form
        "C-c C-d" nil ;julia-snail-doc-lookup
        "C-c C-e" nil ;julia-snail-send-dwim
        "C-c C-k" nil ;julia-snail-send-buffer-file
        "C-c C-l" nil ;julia-snail-send-line
        :map vterm-mode-map
        :i "C-c C-z" nil
        :map markdown-view-mode-map
        :n "q" #'kill-this-buffer))
#+end_src

Some popup rules to make workflows more consistent.

#+begin_src emacs-lisp
(after! julia-repl
  (set-popup-rules!
  '(("^\\*julia.*\\*$" :side right :size 0.5 :ttl nil :quit nil)
    ("^\\*julia.*\\* documentation" :side bottom :size 0.4 :ttl nil)
    ("^\\*julia.*\\* mm" :select t :size #'+popup-shrink-to-fit :modeline t))))
#+end_src
** MATLAB
Rudimentary =matlab-mode= setups.

#+begin_src emacs-lisp
(use-package! matlab
  :commands (matlab-shell matlab-mode)
  :mode ("\\.m\\'" . matlab-mode)
  :hook (matlab-mode . rainbow-delimiters-mode)
  :config
  ;; LSP integration
  (add-to-list 'lsp-language-id-configuration '(matlab-mode . "matlab"))
  ;; setup matlab-shell
  (setq matlab-shell-command (executable-find "matlab"))
  (setq matlab-shell-command-switches '("-nodesktop"))
  ;; popup rules
  (set-popup-rules!
    '(("^\\*MATLAB.*\\*$" :side right :size 0.5 :ttl nil :quit nil)))
  ;; Keybindings
  (map! :map matlab-mode-map
        :g "C-c C-z" #'matlab-show-matlab-shell-buffer
        :map matlab-shell-mode-map
        :i "C-c C-z" #'other-window))
#+end_src

** Elfeeds

#+begin_src emacs-lisp
(use-package! elfeed
  :commands (elfeed)
  :custom
  (rmh-elfeed-org-files (list (concat org-directory "/Feeds/elfeed.org")))
  (elfeed-db-directory (concat org-directory "/Feeds/elfeed.db/"))
  (elfeed-goodies/wide-threshold 0.2)
  :bind ("<f10>" . #'elfeed)
  :config
  ;; (defun hp/elfeed-entry-line-draw (entry)
  ;;   (insert (format "%s" (elfeed-meta--plist entry))))
  (defun hp/elfeed-entry-line-draw (entry)
    "Print ENTRY to the buffer."
    (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
           (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (feed (elfeed-entry-feed entry))
           (feed-title
            (when feed
              (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
           (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
           (tags-str (concat "[" (mapconcat 'identity tags ",") "]"))
           (title-width (- (window-width) elfeed-goodies/feed-source-column-width
                           elfeed-goodies/tag-column-width 4))
           (title-column (elfeed-format-column
                          title (elfeed-clamp
                                 elfeed-search-title-min-width
                                 title-width
                                 title-width)
                          :left))
           (tag-column (elfeed-format-column
                        tags-str (elfeed-clamp (length tags-str)
                                               elfeed-goodies/tag-column-width
                                               elfeed-goodies/tag-column-width)
                        :left))
           (feed-column (elfeed-format-column
                         feed-title (elfeed-clamp elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width)
                         :left))
           (entry-score (elfeed-format-column (number-to-string (elfeed-score-scoring-get-score-from-entry entry)) 6 :left))
           ;; (entry-authors (concatenate-authors
           ;;                 (elfeed-meta entry :authors)))
           ;; (authors-column (elfeed-format-column entry-authors elfeed-goodies/tag-column-width :left))
           )
      (if (>= (window-width) (* (frame-width) elfeed-goodies/wide-threshold))
          (progn
            (insert (propertize entry-score 'face 'elfeed-search-feed-face) " ")
            (insert (propertize date 'face 'elfeed-search-date-face) " ")
            (insert (propertize feed-column 'face 'elfeed-search-feed-face) " ")
            (insert (propertize tag-column 'face 'elfeed-search-tag-face) " ")
            ;; (insert (propertize authors-column 'face 'elfeed-search-tag-face) " ")
            (insert (propertize title 'face title-faces 'kbd-help title))
            )
        (insert (propertize title 'face title-faces 'kbd-help title)))))

  (defun concatenate-authors (authors-list)
    "Given AUTHORS-LIST, list of plists; return string of all authors concatenated."
    (if (> (length authors-list) 1)
        (format "%s et al." (plist-get (nth 0 authors-list) :name))
      (plist-get (nth 0 authors-list) :name)))

  (defun search-header/draw-wide (separator-left separator-right search-filter stats db-time)
    (let* ((update (format-time-string "%Y-%m-%d %H:%M:%S %z" db-time))
           (lhs (list
                 (powerline-raw (-pad-string-to "Score" (- 5 5)) 'powerline-active1 'l)
                 (funcall separator-left 'powerline-active1 'powerline-active2)
                 (powerline-raw (-pad-string-to "Date" (- 9 4)) 'powerline-active2 'l)
                 (funcall separator-left 'powerline-active2 'powerline-active1)
                 (powerline-raw (-pad-string-to "Feed" (- elfeed-goodies/feed-source-column-width 4)) 'powerline-active1 'l)
                 (funcall separator-left 'powerline-active1 'powerline-active2)
                 (powerline-raw (-pad-string-to "Tags" (- elfeed-goodies/tag-column-width 6)) 'powerline-active2 'l)
                 (funcall separator-left 'powerline-active2 'mode-line)
                 (powerline-raw "Subject" 'mode-line 'l)))
           (rhs (search-header/rhs separator-left separator-right search-filter stats update)))
      (concat (powerline-render lhs)
              (powerline-fill 'mode-line (powerline-width rhs))
              (powerline-render rhs))))

  ;; Tag entry as read when open
  (defadvice! hp/mark-read (&rest _)
    :before 'elfeed-search-show-entry
    :before 'elfeed-search-browse-url
    (let* ((offset (- (line-number-at-pos) elfeed-search--offset))
           (current-entry (nth offset elfeed-search-entries)))
      (elfeed-tag-1 current-entry 'read)))

  ;; Faces for diferent kinds of feeds
  (defface hp/elfeed-blog
    `((t :foreground ,(doom-color 'blue)))
    "Marks a Elfeed blog.")
  (push '(blog hp/elfeed-blog)
        elfeed-search-face-alist)
  (push '(read elfeed-search-title-face)
        elfeed-search-face-alist)

  ;; Variables
  (setq elfeed-search-print-entry-function 'hp/elfeed-entry-line-draw
        elfeed-search-filter "@8-weeks-ago -bury "))

#+end_src

Elfeed-score helps with keeping track of the more important entries.

#+begin_src emacs-lisp
(use-package! elfeed-score
  :after elfeed
  :custom
  (elfeed-score-score-file (concat org-directory "/Feeds/elfeed.score"))
  :config
  (map! :map elfeed-search-mode-map
        :n "=" elfeed-score-map)
  (elfeed-score-enable))
#+end_src

Like Org-roam, Elfeed should be opened in it's own workspace:

#+begin_src emacs-lisp
(after! (elfeed)
  (defadvice! hp/elfeed-in-own-workspace (&rest _)
  "Open Elfeeds in its own workspace."
  :before #'elfeed
  (when (modulep! :ui workspaces)
    (+workspace-switch "Elfeeds" t))))
#+end_src
